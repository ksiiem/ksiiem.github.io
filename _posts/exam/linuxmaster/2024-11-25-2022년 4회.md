---
title: "[Linux] 2022년 4회"
categories: [Study, OS]
---

# [1과목] 리눅스 운영 및 관리

---

Q. 다음 중 프린터 작업 큐의 상태 정보를 확인할 때 사용하는 명령으로 알맞은 것은?

> ③
> 

① lp

② lpr

③ lpstat

④ cancel

- 큐의 상태 정보
    - lp = line print
    - stat = status
- lp, lpr
    - 프린터 출력
    

---

Q. 다음 중 원격지 시스템에 있는 프린터를 공유할 때 사용할 수 있는 서비스로 알맞은 것은?

> ④
> 

① OSS

② NFS

③ SANE

④ SAMBA

- 프린터 공유는 SAMBA
- ① 사운드 관련
- ② Network File System - 네트워크 상에서 파일이나 폴더 공유
- ③ 스캐너 관련

---

Q. 다음 설명의 경우 구성하면 좋은 기술로 가장 알맞은 것은?

> ①
> 

```
사용자가 많아져서 디스크의 용량이 부족할 때 손쉽게 용량 증설이 가능하기를 원한다.
```

① LVM

② RAID

③ SAMBA

④ NFS

- Logical Volume Management
    - 물리적으로 붙이고 논리적으로 인식
- ② 복구 기술
- ③ 리눅스와 윈도우 시스템 간의 파일이나 프린터 공유

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ②
> 

```
1998년에 시작된 프로젝트로 사운드카드를 자동으로 구성하게 하고, 사운드 장치 **관리**를 목적으로 하고 있다. 현재 GPL 및 LGPL 라이선스 기반으로 배포되고 있다.
```

① OSS

② ALSA

③ SANE

④ LPRng

- ① **오픈 사운드 시스템**(Open Sound System, OSS)은 [유닉스](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4) 및 [유닉스 계열](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B3%84%EC%97%B4) 운영 체제의 사운드를 만들고 캡처하는 인터페이스이다.(사운드 따는 기술)
- ② **고급 리눅스 사운드 아키텍처**(Advanced Linux Sound Architecture, ALSA)는 [리눅스 커널](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A4%EB%84%90)의 구성 요소 중 하나로 [사운드 카드](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%B4%EB%93%9C_%EC%B9%B4%EB%93%9C)용 [장치 드라이버](https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%B9%98_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84)를 위한 [API](https://ko.wikipedia.org/wiki/API)를 제공하는 [소프트웨어 프레임워크](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)이다. ALSA는 [오픈 사운드 시스템](https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88_%EC%82%AC%EC%9A%B4%EB%93%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C)(OSS)에서 고안 당시 지원하지 못했던 몇가지 다음 기능들을 포함하여 설계되었다.(사운드 관리)
- ③ SANE은 스캐너
- ④ 프린터

---

Q. 다음 중 CUPS 프린팅 시스템 **설정** 및 제어할 때 사용하는 명령으로 가장 알맞은 것은?

> ④
> 

① lpc

② lpr

③ lpq

④ lpadmin

- **CUPS**([영어](https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4): Common Unix Printing System, 공식 명칭으로 CUPS가 더 자주 쓰임)는 컴퓨터를 인쇄 서버로 기능하도록 해주는 [유닉스 계열](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B3%84%EC%97%B4) 운영 체제를 위한 모듈 방식의 프린팅 시스템이다. 컵스(CUPS)는 [애플](https://ko.wikipedia.org/wiki/%EC%95%A0%ED%94%8C)에서 개발한 오픈 소스 형태의 프린터 관련 소프트웨어이다.
- line print admin(설정)

---

Q. 다음 중 10GB 용량을 가진 디스크 5개를 사용해서 RAID-6를 구성했을 경우 실제 사용 가능한 디스크 용량으로 알맞은 것은?

> ③
> 

① 10GB

② 20GB

③ 30GB

④ 40GB

- RAID5의 경우, 손실 비율 33%
- 10*5의 30%는 15%이므로 15GB 이상이 손실 → 35GB → 35GB에서 줄어들 것이므로 30GB

---

Q. 다음은 현재 디렉터리 안에 텍스트 파일을 하나의 파일로 묶는 과정이다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

```
# tar (괄호) text.tar *.txt
```

① cvf

② xvf

③ tvf

④ rvf

- 추가할 때는 r 옵션
- 하나로 묶을 때는 c 옵션
- t는 조회
- x는 푸는 옵션

---

Q. 다음 중 yum 명령을 이용해서 nmap 패키지를 설치하는 명령으로 알맞은 것은?

> ②
> 

① yum nmap install

② yum install nmap

③ yum -i nmap

④ yum -y nmap

- ③ 묻지 않고 yes로 진행

---

Q. 다음 설명에 해당하는 설치 과정으로 알맞은 것은?

> ①
> 

```
Makefile 파일에 저장된 내용을 반영하고, 타깃(target)과 의존성(Dependencies) 관련 작업을 한 후에 최종적으로 실행 파일을 만든다.
```

① make

② configure

③ make install

④ make clean

---

Q. 다음 중 파일의 크기가 가장 작은 압축 형식으로 알맞은 것은?

> ②
> 

① php-8.1.7.tar.gz

② php-8.1.7.tar.xz

③ php-8.1.7.tar.bz2

④ php-8.1.7.tar.Z

- xz, bz2, gz, z(compress) 순서로 효율 좋음
---

Q. 다음 (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

![스크린샷 2024-11-26 오후 6.35.51.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/83e8a32c-b6be-41d6-89b0-43038f8b85cc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.35.51.png)

① -q

② -Q

③ -v

④ -V

- S.5....T.는 vsftpd를 verify 검증한다는 것

---

Q. 다음 중 온라인 패키지 관리 기법으로 틀린 것은?

> ①
> 

① dnf

② yum

③ apt-get

④ YaST

- 기본 패키지 관리와 온라인의 디펜던시 문제까지 해결해주는 방법이 있음
    
    ![스크린샷 2024-11-26 오후 6.41.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/01a0ef1f-e8a9-4c1e-bad9-dc2a2fab6905/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.41.42.png)
    
    - 레드햇 계열 : rpm / yum 을 사용
    - 우분투 계열 : dpkg(데비안 패키지) / apt+get 을 사용
    - 수세 계열: YaST / zypper

---

Q. 다음 중 우분투 리눅스에서 패키지를 설치하는 방법으로 가장 알맞은 것은?

> ③
> 

① rpm 명령을 이용해서 설치한다.

② yum 명령을 이용해서 설치한다.

③ apt-get 명령을 이용해서 설치한다.

④ zypper 명령을 이용해서 설치한다.

---

Q. 다음 중 일반적인 cmake 설치 과정으로 알맞은 것은?

> ①
> 

① cmake → make install

② configure → cmake → make install

③ cmake → configure → make install

④ make → cmake → make install

- cmake(cross platform make) : 빌드 파일을 생성해주는 프로그램
- 일반적인 방법은  configure → make → make install
    
    

---

Q. 다음 중 vi 편집기에서 복사한 내용을 붙여넣기 할 때 사용하는 키로 알맞은 것은?

> ①
> 

① P

② yy

③ dd

④ s

- p : copy
- dd : delete

---

Q. vi 편집기를 이용해서 문서 작업 중에 중단되어서 작업하던 내용을 불러오려고 한다. ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

![스크린샷 2024-11-26 오후 6.58.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/1226260a-4d9a-48bf-b04f-85ca834d6041/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.58.24.png)

① -c

② -r

③ -R

④ +

---

Q. 다음 중 vi 편집기에서 **줄의 시작**이 linux인 경우에만 전부 Linux로 치환하는 명령으로 알맞은 것은?

> ①
> 

① :% s/^linux/Linux/

② :% s/\<linux/Linux/

③ :% s/\<linux\>/Linux/

④ “% s/linux/Linux/

- 줄의 시작은 ^(carrot)

---

Q. 다음 중 리눅스에 사용되는 편집기에 대한 설명으로 틀린 것은?

> ①
> 

① nano 편집기가 개선되어서 등장한 것이 pico 편집기이다.

② vi 편집기가 개선되어서 등장한 것이 vim 편집기이다.

③ vi 편집기는 빌 조이가 개발하였다.

④ emacs는 리처드 스톨만이 개발하였다.

- **pico와 nano**
    - **nano**: 기존의 **pico** 편집기를 개선한 텍스트 편집기.(pico → nano)
    - 주요 개선: 더 많은 기능과 유연성을 제공.
- **빌 조이 (Bill Joy)**
    - Unix와 관련된 여러 소프트웨어 도구를 개발한 컴퓨터 과학자.
    - 대표적인 업적: **vi 편집기**의 창시자.
- **emacs**
    - **Lisp 언어**를 활용하기에 적합한 텍스트 편집기.
    - 주요 기능: 강력한 **치환(문자 대체)** 및 **질의 기능** 지원.
- **리누스 토르발스 (Linus Torvalds)**
    - **Linux 운영체제**의 창시자.
    - 오픈소스 소프트웨어의 상징적 인물.

---

Q. 다음 중 **X 윈도 기반**으로 실행되는 편집기 조합으로 알맞은 것은?

> ④
> 

① gedit, pico

② pico, nano

③ gedit, nano

④ gedit, kwrite

- X윈도 기반은 GUI(graphical) 환경
    - GUI를 구현해줄 수 있는 환경이 X윈도
- 리눅스는 주로 CLI  환경
- **X 윈도 기반** 편집기란, 그래픽 사용자 인터페이스(GUI) 환경에서 동작하는 텍스트 편집기를 의미함. 이는 X Window System 위에서 실행되며, 터미널 기반이 아닌 그래픽 창을 제공하는 편집기들이다.
- **gedit**: GNOME 데스크톱 환경에서 사용하는 기본 텍스트 편집기. X 윈도 기반으로 동작
- **kwrite**: KDE 데스크톱 환경에서 제공하는 GUI 텍스트 편집기. 역시 X 윈도 기반

**① gedit, pico**:

- **gedit**는 X 윈도 기반이지만, **pico**는 터미널 기반 편집기

**② pico, nano**:

- 둘 다 터미널 기반으로 실행. X 윈도와는 무관함

**③ gedit, nano**:

- **gedit**는 X 윈도 기반이지만, **nano**는 터미널 기반

---

Q. 다음 중 emacs 편집기에서 커서의 위치를 현재 커서가 위치한 행의 끝으로 이동하는 조합으로 알맞은 것은?

> ②
> 

① [Ctrl] + [a]

② [Ctrl] + [e]

③ [Ctrl] + [c]

④ [Ctrl] + [x]

![스크린샷 2024-11-26 오후 7.26.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/58a824f1-ac2d-4445-a1a6-5e4794b17bc1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.26.23.png)

- **[Ctrl] + [e]**: Emacs 편집기에서 **커서를 현재 행의 끝으로 이동**하는 단축키
    - **e**는 'end'를 연상할 수 있어, 행의 끝으로 이동하는 기능을 나타냄
- 다른 옵션:
    1. **[Ctrl] + [a]**: 커서를 **현재 행의 시작으로 이동** (a = beginning of line)
    2. **[Ctrl] + [c]**: **명령 실행**을 위한 단축키 조합의 일부로 사용됨 (e.g., [Ctrl] + [c] followed by 다른 키)
    3. **[Ctrl] + [x]**: **Emacs 명령 모드**로 전환하거나 명령어 실행을 위한 접두 키로 사용됨

---

Q. 실행 중인 모든 프로세스의 정보를 출력할 때 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

```
# ps ( 괄호 )
```

① ef

② aux

③ -al

④ -f

- `ps` 명령어는 시스템에서 실행 중인 프로세스 정보를 출력하는 유틸리티. 옵션에 따라 출력되는 정보의 범위와 상세 수준이 달라짐
- **ps aux**:이 명령은 **모든 프로세스** 정보를 출력하는 데 널리 사용됨
    - `a`: 터미널에 종속되지 않은 모든 사용자 프로세스를 포함함
    - `u`: 프로세스를 소유한 사용자 및 CPU/메모리 사용량 등의 정보를 보여줌
    - `x`: 터미널을 갖지 않은 백그라운드 프로세스를 포함함
    - **결과적으로**, 실행 중인 **모든 프로세스** 정보를 표시하는 가장 일반적인 방식임

**① ef**:

- `ps ef`는 유효하지 않다. 그러나 `ps -ef`라면 **표준 형식으로 모든 프로세스 정보를 출력**함. `aux`보다 덜 상세한 정보 형식임

**③ -al**:

- `ps -al`은 현재 사용자와 관련된 프로세스를 **자세히 출력**. 하지만 **모든 사용자**의 프로세스를 출력하지는 않음

**④ -f**:

- `ps -f`는 **현재 사용자의 프로세스를 포맷 형식으로 출력**

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
하나의 프로세스가 다른 프로세스를 실행할 때 사용하는 시스템 호출 방법의 하나로서,
새롭게 생성된 프로세스는 호출한 프로세스의 자식 프로세스가 된다.
```

① exec

② fork

③ init

④ systemd

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/31227cb2-fed4-431a-ac8b-2e391536d605/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/b0398e80-6b00-4df4-a820-07a093b99e34/image.png)

- `fork`는 프로세스 생성에 사용되는 **시스템 호출**로, 기존 프로세스(부모 프로세스)가 새로운 프로세스(자식 프로세스)를 생성하는 데 사용됨
    - 부모 프로세스는 `fork`를 호출하여 자신과 동일한 복사본을 생성함
    - 새로운 프로세스는 **자식 프로세스**로 간주됨
    - 이 호출의 결과로 부모와 자식은 **동시에 실행**되며, **자식 프로세스는 부모 프로세스의 주소 공간을 복사**받음

**① exec**:

- `exec`는 **현재 프로세스를 종료**하고 새로운 프로세스를 실행하는 시스템 호출
- `fork`와는 다르게 프로세스 자체를 교체하며, 새로운 프로세스를 생성하지는 않음

**③ init**:

- `init`은 시스템 부팅 시 가장 먼저 실행되는 **최초의 프로세스**
- 모든 다른 프로세스는 `init`의 자식 프로세스. 새로운 프로세스를 생성하는 호출 방식은 아님

**④ systemd**:

- `systemd`는 현대 리눅스 시스템에서 사용되는 **시스템 및 서비스 관리 데몬**
- `init`의 대체로 개발되었으며, 프로세스를 생성하거나 관리하는 기능을 수행하지만, `fork`와는 다름

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ③
> 

```
보통 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다려야 하는데, 이러한 프로세스를 일컫는 용어이다.
```

① exec 프로세스

② fork 프로세스

③ 포어그라운드(Foreground) 프로세스

④ 백그라운드(Background) 프로세스

- 백그라운드는 기다리지 않고 다른 작업 가능, 포어그라운드는 기다려야 함
- **포어그라운드(Foreground) 프로세스**는 **셸에서 실행된 명령어를 바로 처리하는 프로세스**
    - 사용자가 셸에서 명령을 입력하면 프로세스가 실행되고, 해당 프로세스가 종료될 때까지 셸은 **다른 작업을 받지 않고 대기 상태**가 됨
    - 예를 들어, 터미널에서 `ls`나 `vim` 명령을 실행하면, 결과가 나올 때까지 사용자는 다른 명령을 실행할 수 없음

**① exec 프로세스**:

- `exec`는 **현재 프로세스를 새로운 프로세스로 대체**하는 시스템 호출
- 셸의 실행 대기와는 관련이 없음

**② fork 프로세스**:

- `fork`는 **부모 프로세스에서 자식 프로세스를 복사해 생성**하는 시스템 호출
- 명령 실행과 대기 상태보다는 프로세스 생성과 관련이 있음

**④ 백그라운드(Background) 프로세스**:

- 백그라운드 프로세스는 실행 중에도 셸이 명령 입력을 받을 수 있어, **셸을 차단하지 않음**
- 이는 셸 명령 뒤에 `&`를 붙여 실행(예: `sleep 10 &`)하면 나타남

---

Q. 다음 중 백그라운드로 동작 중인 프로세스를 확인할 때 사용하는 명령어로 알맞은 것은?

> ③
> 

① fg

② bg

③ jobs

④ nohup

- **`jobs` 명령어**란?
    - **현재 셸에서 실행 중인 백그라운드 및 정지된 프로세스를 확인**할 때 사용하는 명령어입니다.
- `jobs`를 입력하면 작업 번호, 상태(정지, 실행 중), 명령 등을 확인할 수 있습니다.
- 주로 **백그라운드 프로세스 관리**에 사용됩니다.

---

1. **① fg**:
    - **백그라운드 작업을 포어그라운드로 전환**하는 명령어입니다.
    - `fg %작업번호` 형식으로 사용하며, `jobs` 명령으로 확인한 작업 번호를 사용합니다.
2. **② bg**:
    - **정지된 작업을 백그라운드에서 계속 실행**하게 만드는 명령어입니다.
    - `bg %작업번호` 형식으로 사용합니다.
3. **④ nohup**:
    - **셸이 종료되어도 프로세스가 계속 실행되도록 만드는 명령어**입니다.
    - 예: `nohup ./my_script.sh &`
    - 백그라운드 작업 확인보다는 프로세스 지속성에 초점이 있습니다.

---

### 요약:

백그라운드에서 실행 중인 프로세스를 **확인**하려면 **`jobs`** 명령어를 사용합니다.

`fg`, `bg`는 프로세스를 관리하거나 상태를 변경할 때 사용됩니다.

---

Q. 프로세스 아이디(PID)가 1222인 bash 프로세스의 우선순위(NI)값이 0이다. 다음 중 이 프로세스의 NI값을 10으로 변경하는 명령으로 알맞은 것은?

> ③
> 

① nice -10 1222

② nice —10 1222

③ nice -10 bash

④ nice —10 bash

- 프로세스 우선순위 값을 변경할 때 PID가 아닌 프로세스명으로 함
- renice는 프로세스ID 사용

- nice는 -20~19의 범위
    - -20 : 최강 → 무조건 실행(마이너스, 극강으로 priority 올려줌)
    - 19 : 실행 천천히 가능

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/d4f31ad9-f064-49ba-8e28-0e9e655b88bd/image.png)

- `nice` 명령은 프로세스의 **우선순위(NI, Niceness 값)**를 조정할 때 사용됨
- **`NI` 값**은 **-20(가장 높은 우선순위)**에서 19(가장 낮은 우선순위)까지 설정할 수 있음
- 기본적으로 새로운 프로세스를 실행하며 `NI` 값을 설정함

**① nice -10 1222, ② nice —10 1222**

- 잘못된 명령어. `nice`는 **프로세스 ID(PID)를 직접 지정**할 수 없음
- ~~우선순위를 조정하려면~~ `renice` 명령어를 사용해야 함

**③ nice -10 bash**

- 올바른 명령어
- 이 명령은 `bash`라는 이름의 새 프로세스를 **NI 값 10**으로 시작함
- 이미 실행 중인 프로세스의 우선순위는 변경할 수 없음

---

Q. 다음 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ①
> 

```
프로세스 우선순위와 관련된 항목에는 (㉠)와 (㉡)가 있다. 
(㉠)는 사용자가 명령자가 명령어를 이용해 값을 바꿀 수가 있고,
바뀐 값을 토대로 (㉡)의 값이 변경되면서 적용된다.
```

① ㉠ NI ㉡ PRI

② ㉠ PRI ㉡ NI

③ ㉠ NICE ㉡ RENICE

④ ㉠ RENICE ㉡ NICE

- PRI는 커널이 NI를 읽어서 그것에 맞게 적절하게 운영
- ps -aux나 ps ef를 통해 확인 가능
- NI (Niceness 값)와 PRI (Priority 값)는 프로세스 우선순위에 밀접하게 연관된 두 가지 개념임
    - **NI (Niceness):**
        - 사용자가 직접 설정할 수 있는 **프로세스 우선순위 조정 값**
        - 값의 범위는 -20(가장 높은 우선순위)에서 19(가장 낮은 우선순위)
        - 명령어 예: `nice` 또는 `renice`.
    - **PRI (Priority):**
        - 실제 **커널이 프로세스에 부여하는 우선순위 값**
        - **NI 값을 기준으로 계산**되며, 프로세스의 실행 스케줄에 영향을 미침
    - 사용자가 **NI** 값을 조정하면, 커널이 이를 기준으로 **PRI** 값을 재계산
    - 따라서 **NI는 사용자 설정값**, **PRI는 커널 설정값**

---

Q. 다음 중 SIGKILL 시그널에 부여된 번호값으로 알맞은 것은?

> ②
> 

① 1

② 9

③ 15

④ 20

- **SIGKILL**은 프로세스를 강제로 종료하는 데 사용되는 시그널로, 이에 대응하는 번호값은 **9**
- 이 시그널은 프로세스가 종료를 거부하거나 응답하지 않을 때 강제적으로 프로세스를 종료할 수 있는 최후의 수단

```
- SIGKILL(9): 강제 종료.
- 다른 시그널보다 우선순위가 높으며, 일반적으로 `kill -9`로 사용됨
```

- 주요 시그널 번호와 의미:
    - **1 (SIGHUP):**
        - 프로세스의 연결 끊김(종료)을 의미하며, 주로 데몬을 재로드할 때 사용.
    - **9 (SIGKILL):**
        - 프로세스를 **즉시 종료**시키는 시그널로, 프로세스가 처리할 여유가 없음.
        - **무조건적인 종료**를 보장하기 때문에, 프로세스가 종료되지 않을 때 사용하는 강제 수단.
    - **15 (SIGTERM):**
        - 프로세스 종료 요청 시그널로, 프로세스가 정상적으로 종료할 시간을 주는 일반적인 종료 방법.
    - **20 (SIGTSTP):**
        - 키보드에서 **Ctrl+Z**를 눌렀을 때 발생하며, 프로세스를 일시 정지(Suspend)함.
- 명령어 예시:
    - **SIGKILL을 이용해 프로세스 강제 종료:**
        
        ```bash
        kill -9 [PID]
        ```
        
    - **다른 시그널로 종료:**
        - SIGTERM:
        
        ```bash
        kill -15 [PID]
        
        ```
        

---

Q. 다음 중 시그널 목록 정보를 확인할 때 사용하는 명령어로 알맞은 것은?

> ②
> 

① ps

② kill

③ nohup

④ nice

- 시그널 목록 정보를 확인하려면 `kill` 명령어에 `-l` 옵션을 사용함.
- `kill -l`을 입력하면 **시그널 이름**과 **시그널 번호**의 전체 목록이 출력됨.

1. **ps**
    - 현재 실행 중인 프로세스의 목록을 확인하는 명령어.
    - 시그널과는 관련 없음.
2. **kill**
    - 프로세스에 시그널을 전달하여 특정 작업(종료, 재시작 등)을 수행하도록 요청하는 명령어.
    - `kill -l` 옵션으로 **모든 시그널의 목록과 번호**를 확인할 수 있음.
        
        ```bash
        $ kill -l
        HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM ...
        
        ```
        
3. **nohup**
    - 프로세스를 **로그아웃 이후에도 계속 실행**되도록 백그라운드에서 실행할 때 사용하는 명령어.
    - 프로세스를 끄지 않고 뒷단에서라도 돌려라. 백에서라도 계속 돌려라.
4. **nice**
    - 프로세스의 **우선순위(NI 값)**를 조정할 때 사용하는 명령어.

---

Q. cron을 이용해서 해당 스크립트를 매주 수요일 오전 4시 1분에 주기적으로 실행하려고 한다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> **④**
> 

```bash
(괄호) /etc/backup.sh
```

① 1 4 3 * *

② 4 1 3 * *

③ 4 1 * * 3

④ 1 4 * * 3

- `cron`에서 **스케줄링 형식**:
    
    ```bash
    분(0-59) 시(0-23) 일(1-31) 월(1-12) 요일(0-7)
    ```
    
    - **분**: 1
    - **시**: 4
    - **일**: `*`(모든 날짜)
    - **월**:`*`(모든 달)
    - **요일**: 3 (**수요일**)
    - `cron` 명령어에서 요일은 마지막 항목(0=일요일, 3=수요일)이며, **수요일 오전 4시 1분**에 실행되도록 설정하려면 `1 4 * * 3`을 사용한다.

① 1 4 3 * ***

- "3일(날짜)"에 실행됨. 요일과는 관련 없음.

② 4 1 3 * ***

- 시간(4시 1분)이 잘못 배치되었음.
- 또한 "3일(날짜)"에 실행됨.

**③ 4 1 * * 3**

- 시간 형식이 잘못되었음(4시 1분이 아니라 1시 4분으로 처리됨).

**④ 1 4 * * 3**

- 올바른 형식으로, **수요일 오전 4시 1분**에 실행됨.

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
특정 데몬 하나만 메모리에 상주하면서 다수의 데몬을 관리하는 방식이다.
특정 데몬이 관리하는 서비스에 대한 요청이 들어오면 관련 데몬을 실행하여 메모리에 올려주고
서비스 이용이 끝나면 메모리에서 제거하여 효율적인 관리를 수행하였다.
리눅스 커널 24 버전부터 사용되었다.
```

① inetd

② xinetd

③ init

④ systemd

- 메모리의 효율적인 관리 : inetd
    - standalone 방식 : 유저가 무슨 명령을 내릴지 모르므로 계속 데몬을 뒤에서 프로세스를 올려서 돌리는는 방식
    - inetd 방식 : 메모리의 효율이 안 좋으므로 호출하는 방식

- `xinetd`는 **슈퍼 데몬(Super Daemon)**으로, 여러 서비스 요청을 관리하는 데몬이다. 이는 `inetd`의 확장 버전이며, 보다 효율적으로 **다수의 데몬 및 서비스 관리**를 수행한다.
- 주요 특징:
    - **메모리 효율성**: 요청이 들어오면 해당 서비스를 실행하고, 사용이 끝나면 메모리에서 제거.
    - **접근 제어 및 로깅 기능 강화**: inetd에 비해 보안과 서비스 관리 기능이 개선됨.
    - 리눅스 커널 **2.4** 버전부터 사용되었다.

**① inetd**:

- 초기 슈퍼 데몬으로, 서비스 요청을 관리했으나 보안과 기능이 단순함.
- `xinetd`로 대체됨.

**② xinetd**:

- `inetd`의 개선 버전으로, 문제에서 언급된 **효율적인 서비스 관리** 및 **메모리 관리** 방식에 부합.

**③ init**:

- 초기화 데몬으로, 시스템 부팅 시 프로세스를 초기화하고 관리.
- 문제의 "다수의 데몬 관리"와 관련 없음.

**④ systemd**:

- init의 대체로 설계된 최신 시스템 관리 도구.
- 시스템 부팅 및 유닛 관리(서비스, 소켓 등)에 초점.

```
1. 메모리의 효율적인 관리 - inetd 방식
inetd(Internet Super Daemon)는 네트워크 서비스의 메모리 효율성을 높이기 위해 설계된 방식이다.
데몬을 항상 메모리에 상주시키는 방식이 아니라, 서비스 요청이 들어올 때 필요한 데몬을 실행하는 방식으로 작동한다.
예: FTP, Telnet 등 네트워크 관련 서비스.

2. Standalone 방식과 inetd 방식의 차이점
Standalone 방식:
서비스 데몬이 항상 메모리에 상주하며, 사용자가 요청할 때를 기다림.
장점: 요청에 대해 빠른 응답 가능.
단점: 여러 데몬이 항상 메모리를 차지하므로 비효율적.

inetd 방식:
서비스 요청이 있을 때만 데몬을 실행하여 메모리를 효율적으로 관리.
장점: 메모리 사용량 감소, 관리 간소화.
단점: 요청 시 데몬을 실행해야 하므로 초기 응답 속도가 다소 느릴 수 있음.

3. 한계와 개선
inetd는 초기 방식이었으며, 보안 및 기능 개선이 필요했음.
이를 해결하기 위해 xinetd가 등장.
xinetd는 inetd의 확장판으로, 보안 및 로깅 기능이 강화됨.

- Standalone 방식 → 데몬 상주로 비효율적.
- inetd 방식 → 메모리 효율적 관리.
- xinetd 방식 → inetd의 단점을 보완한 고급 슈퍼 데몬.
- inetd 방식은 Standalone 방식의 메모리 비효율성을 해결하기 위해 요청 시 데몬을 호출하여 작동하는 메모리 효율적인 방식이다.
```

---

Q. 다음 중 배시셸에서 aaa라고 입력하면 ‘ls -alF’가 실행되도록 설정하는 명령으로 알맞은 것은?

> ②
> 

① alias aaa ‘ls -alF’

② alias aaa=’ls -alF’

③ alias ‘ls -alF’ aaa

④ alias ‘ls -alF’ = aaa

- **`alias` 명령어**는 **명령어를 짧은 이름으로 대체**하거나 새로 정의할 때 사용한다.
    - 형식:
        
        ```bash
        alias [별칭]=’[실행 명령어]'
        ```
        
    - `alias aaa='ls -alF'`:
    → `aaa`를 입력하면 `ls -alF` 명령어가 실행됨.

**① alias aaa ‘ls -alF’**

- 등호(=)가 없으므로 형식이 잘못됨.

**② alias aaa=’ls -alF’**

- 올바른 형식으로 별칭 설정이 가능.

**③ alias ‘ls -alF’ aaa**

- 형식이 잘못됨. `alias`는 `[별칭]=[명령어]` 구조를 사용해야 함.

**④ alias ‘ls -alF’ = aaa**

- 형식이 잘못됨. **실행 명령어를 별칭에 할당**하는 방식이 아님.

---

Q. 다음 설명에 해당하는 셸로 알맞은 것은?

> ①
> 

```
1983년 AT&T사의 벨 연구소에 근무하던 데이비드 **콘**이 개발한 셸로 본 셸을 확장해서 만들어졌다.
작업제어, 에일리어스, 히스토리 기능 등을 제공한다.
```

① **k**sh

② zsh

③ dash

④ bash

- **ksh (KornShell)**:
    - 1983년, AT&T 벨 연구소의 데이비드 콘(David Korn)이 개발.
    - 본 셸(Bourne Shell, sh)을 기반으로 하여 작업 제어, 별칭(alias), 명령어 기록(history) 등의 기능을 추가.
    - 강력한 스크립트 작성 기능과 효율성 덕분에 많은 유닉스 시스템에서 사용.

**① ksh**

- 정답. 데이비드 콘이 개발했으며 본 셸의 확장 버전이다.

**② zsh**

- Z 셸(Zsh)은 K 셸과 Bash를 결합하고 확장한 최신 셸로, **1990년대에 개발**됨.
- 본 셸의 직접적인 확장 버전은 아님.

**③ dash**

- Dash(Debian Almquist Shell)는 빠르고 가벼운 POSIX 호환 셸로, KornShell이나 본 셸의 확장과는 관련이 없음.

**④ bash**

- GNU 프로젝트에서 개발한 Bourne-Again Shell.
- 본 셸을 대체하기 위해 만들어졌으나, KornShell과는 직접적인 관계가 없음.

---

Q. 다음 결과에 해당하는 명령으로 알맞은 것은?

> ②
> 

![스크린샷 2024-11-27 오후 8.14.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/e5777a55-f20a-4de7-89c5-6cf1a4f2947b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.14.57.png)

① sh -l

② chsh -l

③ grep sh /etc/passwd

④ cat /etc/bashrc

- 주어진 출력은 시스템에 설치된 **사용 가능한 셸 목록**을 보여줌.
이와 같은 결과는 **chsh** 명령어의 `l` 옵션을 통해 확인할 수 있다.
- 내가 바꿀 수 있는 셸의 리스트를 봄

**① `sh -l`**

- `sh` 명령은 Bourne 셸을 실행.
- `l` 옵션은 로그인 셸로 실행한다는 뜻으로, 출력과는 관련이 없음.

**② `chsh -l`**

- **chsh (change shell)** 명령의 `l` 옵션은 시스템에서 사용 가능한 셸 목록을 출력함
- **정답**.

**③ `grep sh /etc/passwd`**

- `/etc/passwd` 파일에서 "sh" 문자열을 포함하는 라인을 검색하는 명령.
- passwd는 계정 정보를 가지고 있으므로 아님.

**④ `cat /etc/bashrc`**

- `/etc/bashr`는 별칭 파일.

---

Q. 다음 중 ( 괄호 ) 안에 들어갈 명령의 결과로 알맞은 것은?

> ④
> 

```bash
[ihduser@ihd ~]$ user=kaitman 
[ihduser@ihd ~]$ echo $user
( 괄호 )
```

① 아무것도 출력되지 않는다.

② $user

③ ihduser

④ kaitman

- `$user`는 변수를 사용하려고 하며, 이미 해당 변수가 선언되고 값이 할당되었음.
    
    ```bash
    user=kaitman  # 'user' 변수에 'kaitman' 값을 할당
    echo $user    # 변수 'user'의 값을 출력
    ```
    
    - `$user`는 `echo` 명령어에 의해 값을 출력합니다.
    - `user` 변수는 값으로 `kaitman`을 가지고 있으므로 출력 결과는 `kaitman`이 됨

**① 아무것도 출력되지 않는다.**

- **오답**: 변수 `user`는 이미 값이 할당되어 있으므로 값이 출력됨.

**② `$user`**

- **오답**: `$user`는 변수를 참조하는 표현이며, 변수의 값(`kaitman`)이 출력됨.

**③ ihduser**

- **오답**: `ihduser`는 현재 사용자 계정 이름일 가능성이 있지만, 이는 `$user` 변수와는 관계가 없음.

**④ kaitman**

- **정답**: `$user`는 `kaitman` 값을 가지고 있으므로 올바른 출력 결과.

---

Q. 다음 중 최근에 입력한 5개의 명령 목록을 확인하기 위한 명령으로 알맞은 것은?

> ③
> 

① !5

② !-5

③ history 5

④ history -5

- **`history`**: 셸에서 실행된 명령의 기록을 관리하고 출력하는 명령어.
- **`history [숫자]`**: 기록된 명령 중 최근 **숫자**에 해당하는 갯수만큼 출력. 따라서, `history 5`는 최근 **5개의 명령 목록**을 출력한다.

1. **① `!5`**
    - **오답**: `!5`는 **명령 기록 번호 5번**에 해당하는 명령을 **재실행**하는 명령. 최근 5개의 명령을 확인하는 목적과는 다름.
2. **② `!-5`**
    - **오답**: `!-5`는 현재 실행 중인 명령을 기준으로 **최근 5번째 명령을 재실행**하는 명령.
3. **③ `history 5`**
    - **정답**: `history 5`는 **최근 입력한 5개의 명령을 목록 형태로 확인**하는 명령.
4. **④ `history -5`**
    - **오답**: `history -5`는 잘못된 문법. `history` 명령은 `-`옵션을 사용하지 않음.

---

Q. 다음 중 시스템 전체 사용자에게 적용되는 함수(function)이나 에일리어스(alias)를 설정할 때 사용하는 파일로 가장 알맞은 것은?

> ①
> 

① /etc/bashrc

② /etc/profile

③ ~/.bashrc 

④ ~/.bash_profile

- 시스템 전체이므로 ①(bashrc)
- `.`찍힌 숨긴 파일들은 개인 사용자
- profile에는 전체에 대한 환경변수나 여러 가지 function이 들어감
