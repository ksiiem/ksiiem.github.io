---
title: "[Linux] 2022년 4회"
categories: [Study, OS]
---

# [1과목] 리눅스 운영 및 관리

---

Q. 다음 중 프린터 작업 큐의 상태 정보를 확인할 때 사용하는 명령으로 알맞은 것은?

> ③
> 

① lp

② lpr

③ lpstat

④ cancel

- 큐의 상태 정보
    - lp = line print
    - stat = status
- lp, lpr
    - 프린터 출력
    

---

Q. 다음 중 원격지 시스템에 있는 프린터를 공유할 때 사용할 수 있는 서비스로 알맞은 것은?

> ④
> 

① OSS

② NFS

③ SANE

④ SAMBA

- 프린터 공유는 SAMBA
- ① 사운드 관련
- ② Network File System - 네트워크 상에서 파일이나 폴더 공유
- ③ 스캐너 관련

---

Q. 다음 설명의 경우 구성하면 좋은 기술로 가장 알맞은 것은?

> ①
> 

```
사용자가 많아져서 디스크의 용량이 부족할 때 손쉽게 용량 증설이 가능하기를 원한다.
```

① LVM

② RAID

③ SAMBA

④ NFS

- Logical Volume Management
    - 물리적으로 붙이고 논리적으로 인식
- ② 복구 기술
- ③ 리눅스와 윈도우 시스템 간의 파일이나 프린터 공유

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ②
> 

```
1998년에 시작된 프로젝트로 사운드카드를 자동으로 구성하게 하고, 사운드 장치 **관리**를 목적으로 하고 있다. 현재 GPL 및 LGPL 라이선스 기반으로 배포되고 있다.
```

① OSS

② ALSA

③ SANE

④ LPRng

- ① **오픈 사운드 시스템**(Open Sound System, OSS)은 [유닉스](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4) 및 [유닉스 계열](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B3%84%EC%97%B4) 운영 체제의 사운드를 만들고 캡처하는 인터페이스이다.(사운드 따는 기술)
- ② **고급 리눅스 사운드 아키텍처**(Advanced Linux Sound Architecture, ALSA)는 [리눅스 커널](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A4%EB%84%90)의 구성 요소 중 하나로 [사운드 카드](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%B4%EB%93%9C_%EC%B9%B4%EB%93%9C)용 [장치 드라이버](https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%B9%98_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84)를 위한 [API](https://ko.wikipedia.org/wiki/API)를 제공하는 [소프트웨어 프레임워크](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)이다. ALSA는 [오픈 사운드 시스템](https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88_%EC%82%AC%EC%9A%B4%EB%93%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C)(OSS)에서 고안 당시 지원하지 못했던 몇가지 다음 기능들을 포함하여 설계되었다.(사운드 관리)
- ③ SANE은 스캐너
- ④ 프린터

---

Q. 다음 중 CUPS 프린팅 시스템 **설정** 및 제어할 때 사용하는 명령으로 가장 알맞은 것은?

> ④
> 

① lpc

② lpr

③ lpq

④ lpadmin

- **CUPS**([영어](https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4): Common Unix Printing System, 공식 명칭으로 CUPS가 더 자주 쓰임)는 컴퓨터를 인쇄 서버로 기능하도록 해주는 [유닉스 계열](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B3%84%EC%97%B4) 운영 체제를 위한 모듈 방식의 프린팅 시스템이다. 컵스(CUPS)는 [애플](https://ko.wikipedia.org/wiki/%EC%95%A0%ED%94%8C)에서 개발한 오픈 소스 형태의 프린터 관련 소프트웨어이다.
- line print admin(설정)

---

Q. 다음 중 10GB 용량을 가진 디스크 5개를 사용해서 RAID-6를 구성했을 경우 실제 사용 가능한 디스크 용량으로 알맞은 것은?

> ③
> 

① 10GB

② 20GB

③ 30GB

④ 40GB

- RAID5의 경우, 손실 비율 33%
- 10*5의 30%는 15%이므로 15GB 이상이 손실 → 35GB → 35GB에서 줄어들 것이므로 30GB

---

Q. 다음은 현재 디렉터리 안에 텍스트 파일을 하나의 파일로 묶는 과정이다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

```
# tar (괄호) text.tar *.txt
```

① cvf

② xvf

③ tvf

④ rvf

- 추가할 때는 r 옵션
- 하나로 묶을 때는 c 옵션
- t는 조회
- x는 푸는 옵션

---

Q. 다음 중 yum 명령을 이용해서 nmap 패키지를 설치하는 명령으로 알맞은 것은?

> ②
> 

① yum nmap install

② yum install nmap

③ yum -i nmap

④ yum -y nmap

- ③ 묻지 않고 yes로 진행

---

Q. 다음 설명에 해당하는 설치 과정으로 알맞은 것은?

> ①
> 

```
Makefile 파일에 저장된 내용을 반영하고, 타깃(target)과 의존성(Dependencies) 관련 작업을 한 후에 최종적으로 실행 파일을 만든다.
```

① make

② configure

③ make install

④ make clean

---

Q. 다음 중 파일의 크기가 가장 작은 압축 형식으로 알맞은 것은?

> ②
> 

① php-8.1.7.tar.gz

② php-8.1.7.tar.xz

③ php-8.1.7.tar.bz2

④ php-8.1.7.tar.Z

- xz, bz2, gz, z(compress) 순서로 효율 좋음
---

Q. 다음 (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

![스크린샷 2024-11-26 오후 6.35.51.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/83e8a32c-b6be-41d6-89b0-43038f8b85cc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.35.51.png)

① -q

② -Q

③ -v

④ -V

- S.5....T.는 vsftpd를 verify 검증한다는 것

---

Q. 다음 중 온라인 패키지 관리 기법으로 틀린 것은?

> ①
> 

① dnf

② yum

③ apt-get

④ YaST

- 기본 패키지 관리와 온라인의 디펜던시 문제까지 해결해주는 방법이 있음
    
    ![스크린샷 2024-11-26 오후 6.41.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/01a0ef1f-e8a9-4c1e-bad9-dc2a2fab6905/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.41.42.png)
    
    - 레드햇 계열 : rpm / yum 을 사용
    - 우분투 계열 : dpkg(데비안 패키지) / apt+get 을 사용
    - 수세 계열: YaST / zypper

---

Q. 다음 중 우분투 리눅스에서 패키지를 설치하는 방법으로 가장 알맞은 것은?

> ③
> 

① rpm 명령을 이용해서 설치한다.

② yum 명령을 이용해서 설치한다.

③ apt-get 명령을 이용해서 설치한다.

④ zypper 명령을 이용해서 설치한다.

---

Q. 다음 중 일반적인 cmake 설치 과정으로 알맞은 것은?

> ①
> 

① cmake → make install

② configure → cmake → make install

③ cmake → configure → make install

④ make → cmake → make install

- cmake(cross platform make) : 빌드 파일을 생성해주는 프로그램
- 일반적인 방법은  configure → make → make install
    
    

---

Q. 다음 중 vi 편집기에서 복사한 내용을 붙여넣기 할 때 사용하는 키로 알맞은 것은?

> ①
> 

① P

② yy

③ dd

④ s

- p : copy
- dd : delete

---

Q. vi 편집기를 이용해서 문서 작업 중에 중단되어서 작업하던 내용을 불러오려고 한다. ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

![스크린샷 2024-11-26 오후 6.58.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/1226260a-4d9a-48bf-b04f-85ca834d6041/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.58.24.png)

① -c

② -r

③ -R

④ +

---

Q. 다음 중 vi 편집기에서 **줄의 시작**이 linux인 경우에만 전부 Linux로 치환하는 명령으로 알맞은 것은?

> ①
> 

① :% s/^linux/Linux/

② :% s/\<linux/Linux/

③ :% s/\<linux\>/Linux/

④ “% s/linux/Linux/

- 줄의 시작은 ^(carrot)

---

Q. 다음 중 리눅스에 사용되는 편집기에 대한 설명으로 틀린 것은?

> ①
> 

① nano 편집기가 개선되어서 등장한 것이 pico 편집기이다.

② vi 편집기가 개선되어서 등장한 것이 vim 편집기이다.

③ vi 편집기는 빌 조이가 개발하였다.

④ emacs는 리처드 스톨만이 개발하였다.

- **pico와 nano**
    - **nano**: 기존의 **pico** 편집기를 개선한 텍스트 편집기.(pico → nano)
    - 주요 개선: 더 많은 기능과 유연성을 제공.
- **빌 조이 (Bill Joy)**
    - Unix와 관련된 여러 소프트웨어 도구를 개발한 컴퓨터 과학자.
    - 대표적인 업적: **vi 편집기**의 창시자.
- **emacs**
    - **Lisp 언어**를 활용하기에 적합한 텍스트 편집기.
    - 주요 기능: 강력한 **치환(문자 대체)** 및 **질의 기능** 지원.
- **리누스 토르발스 (Linus Torvalds)**
    - **Linux 운영체제**의 창시자.
    - 오픈소스 소프트웨어의 상징적 인물.

---

Q. 다음 중 **X 윈도 기반**으로 실행되는 편집기 조합으로 알맞은 것은?

> ④
> 

① gedit, pico

② pico, nano

③ gedit, nano

④ gedit, kwrite

- X윈도 기반은 GUI(graphical) 환경
    - GUI를 구현해줄 수 있는 환경이 X윈도
- 리눅스는 주로 CLI  환경
- **X 윈도 기반** 편집기란, 그래픽 사용자 인터페이스(GUI) 환경에서 동작하는 텍스트 편집기를 의미함. 이는 X Window System 위에서 실행되며, 터미널 기반이 아닌 그래픽 창을 제공하는 편집기들이다.
- **gedit**: GNOME 데스크톱 환경에서 사용하는 기본 텍스트 편집기. X 윈도 기반으로 동작
- **kwrite**: KDE 데스크톱 환경에서 제공하는 GUI 텍스트 편집기. 역시 X 윈도 기반

**① gedit, pico**:

- **gedit**는 X 윈도 기반이지만, **pico**는 터미널 기반 편집기

**② pico, nano**:

- 둘 다 터미널 기반으로 실행. X 윈도와는 무관함

**③ gedit, nano**:

- **gedit**는 X 윈도 기반이지만, **nano**는 터미널 기반

---

Q. 다음 중 emacs 편집기에서 커서의 위치를 현재 커서가 위치한 행의 끝으로 이동하는 조합으로 알맞은 것은?

> ②
> 

① [Ctrl] + [a]

② [Ctrl] + [e]

③ [Ctrl] + [c]

④ [Ctrl] + [x]

![스크린샷 2024-11-26 오후 7.26.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/58a824f1-ac2d-4445-a1a6-5e4794b17bc1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.26.23.png)

- **[Ctrl] + [e]**: Emacs 편집기에서 **커서를 현재 행의 끝으로 이동**하는 단축키
    - **e**는 'end'를 연상할 수 있어, 행의 끝으로 이동하는 기능을 나타냄
- 다른 옵션:
    1. **[Ctrl] + [a]**: 커서를 **현재 행의 시작으로 이동** (a = beginning of line)
    2. **[Ctrl] + [c]**: **명령 실행**을 위한 단축키 조합의 일부로 사용됨 (e.g., [Ctrl] + [c] followed by 다른 키)
    3. **[Ctrl] + [x]**: **Emacs 명령 모드**로 전환하거나 명령어 실행을 위한 접두 키로 사용됨

---

Q. 실행 중인 모든 프로세스의 정보를 출력할 때 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

```
# ps ( 괄호 )
```

① ef

② aux

③ -al

④ -f

- `ps` 명령어는 시스템에서 실행 중인 프로세스 정보를 출력하는 유틸리티. 옵션에 따라 출력되는 정보의 범위와 상세 수준이 달라짐
- **ps aux**:이 명령은 **모든 프로세스** 정보를 출력하는 데 널리 사용됨
    - `a`: 터미널에 종속되지 않은 모든 사용자 프로세스를 포함함
    - `u`: 프로세스를 소유한 사용자 및 CPU/메모리 사용량 등의 정보를 보여줌
    - `x`: 터미널을 갖지 않은 백그라운드 프로세스를 포함함
    - **결과적으로**, 실행 중인 **모든 프로세스** 정보를 표시하는 가장 일반적인 방식임

**① ef**:

- `ps ef`는 유효하지 않다. 그러나 `ps -ef`라면 **표준 형식으로 모든 프로세스 정보를 출력**함. `aux`보다 덜 상세한 정보 형식임

**③ -al**:

- `ps -al`은 현재 사용자와 관련된 프로세스를 **자세히 출력**. 하지만 **모든 사용자**의 프로세스를 출력하지는 않음

**④ -f**:

- `ps -f`는 **현재 사용자의 프로세스를 포맷 형식으로 출력**

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
하나의 프로세스가 다른 프로세스를 실행할 때 사용하는 시스템 호출 방법의 하나로서,
새롭게 생성된 프로세스는 호출한 프로세스의 자식 프로세스가 된다.
```

① exec

② fork

③ init

④ systemd

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/31227cb2-fed4-431a-ac8b-2e391536d605/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/b0398e80-6b00-4df4-a820-07a093b99e34/image.png)

- `fork`는 프로세스 생성에 사용되는 **시스템 호출**로, 기존 프로세스(부모 프로세스)가 새로운 프로세스(자식 프로세스)를 생성하는 데 사용됨
    - 부모 프로세스는 `fork`를 호출하여 자신과 동일한 복사본을 생성함
    - 새로운 프로세스는 **자식 프로세스**로 간주됨
    - 이 호출의 결과로 부모와 자식은 **동시에 실행**되며, **자식 프로세스는 부모 프로세스의 주소 공간을 복사**받음

**① exec**:

- `exec`는 **현재 프로세스를 종료**하고 새로운 프로세스를 실행하는 시스템 호출
- `fork`와는 다르게 프로세스 자체를 교체하며, 새로운 프로세스를 생성하지는 않음

**③ init**:

- `init`은 시스템 부팅 시 가장 먼저 실행되는 **최초의 프로세스**
- 모든 다른 프로세스는 `init`의 자식 프로세스. 새로운 프로세스를 생성하는 호출 방식은 아님

**④ systemd**:

- `systemd`는 현대 리눅스 시스템에서 사용되는 **시스템 및 서비스 관리 데몬**
- `init`의 대체로 개발되었으며, 프로세스를 생성하거나 관리하는 기능을 수행하지만, `fork`와는 다름

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ③
> 

```
보통 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다려야 하는데, 이러한 프로세스를 일컫는 용어이다.
```

① exec 프로세스

② fork 프로세스

③ 포어그라운드(Foreground) 프로세스

④ 백그라운드(Background) 프로세스

- 백그라운드는 기다리지 않고 다른 작업 가능, 포어그라운드는 기다려야 함
- **포어그라운드(Foreground) 프로세스**는 **셸에서 실행된 명령어를 바로 처리하는 프로세스**
    - 사용자가 셸에서 명령을 입력하면 프로세스가 실행되고, 해당 프로세스가 종료될 때까지 셸은 **다른 작업을 받지 않고 대기 상태**가 됨
    - 예를 들어, 터미널에서 `ls`나 `vim` 명령을 실행하면, 결과가 나올 때까지 사용자는 다른 명령을 실행할 수 없음

**① exec 프로세스**:

- `exec`는 **현재 프로세스를 새로운 프로세스로 대체**하는 시스템 호출
- 셸의 실행 대기와는 관련이 없음

**② fork 프로세스**:

- `fork`는 **부모 프로세스에서 자식 프로세스를 복사해 생성**하는 시스템 호출
- 명령 실행과 대기 상태보다는 프로세스 생성과 관련이 있음

**④ 백그라운드(Background) 프로세스**:

- 백그라운드 프로세스는 실행 중에도 셸이 명령 입력을 받을 수 있어, **셸을 차단하지 않음**
- 이는 셸 명령 뒤에 `&`를 붙여 실행(예: `sleep 10 &`)하면 나타남

---

Q. 다음 중 백그라운드로 동작 중인 프로세스를 확인할 때 사용하는 명령어로 알맞은 것은?

> ③
> 

① fg

② bg

③ jobs

④ nohup

- **`jobs` 명령어**란?
    - **현재 셸에서 실행 중인 백그라운드 및 정지된 프로세스를 확인**할 때 사용하는 명령어입니다.
- `jobs`를 입력하면 작업 번호, 상태(정지, 실행 중), 명령 등을 확인할 수 있습니다.
- 주로 **백그라운드 프로세스 관리**에 사용됩니다.

---

1. **① fg**:
    - **백그라운드 작업을 포어그라운드로 전환**하는 명령어입니다.
    - `fg %작업번호` 형식으로 사용하며, `jobs` 명령으로 확인한 작업 번호를 사용합니다.
2. **② bg**:
    - **정지된 작업을 백그라운드에서 계속 실행**하게 만드는 명령어입니다.
    - `bg %작업번호` 형식으로 사용합니다.
3. **④ nohup**:
    - **셸이 종료되어도 프로세스가 계속 실행되도록 만드는 명령어**입니다.
    - 예: `nohup ./my_script.sh &`
    - 백그라운드 작업 확인보다는 프로세스 지속성에 초점이 있습니다.

---

### 요약:

백그라운드에서 실행 중인 프로세스를 **확인**하려면 **`jobs`** 명령어를 사용합니다.

`fg`, `bg`는 프로세스를 관리하거나 상태를 변경할 때 사용됩니다.

---

Q. 프로세스 아이디(PID)가 1222인 bash 프로세스의 우선순위(NI)값이 0이다. 다음 중 이 프로세스의 NI값을 10으로 변경하는 명령으로 알맞은 것은?

> ③
> 

① nice -10 1222

② nice —10 1222

③ nice -10 bash

④ nice —10 bash

- 프로세스 우선순위 값을 변경할 때 PID가 아닌 프로세스명으로 함
- renice는 프로세스ID 사용

- nice는 -20~19의 범위
    - -20 : 최강 → 무조건 실행(마이너스, 극강으로 priority 올려줌)
    - 19 : 실행 천천히 가능

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/d4f31ad9-f064-49ba-8e28-0e9e655b88bd/image.png)

- `nice` 명령은 프로세스의 **우선순위(NI, Niceness 값)**를 조정할 때 사용됨
- **`NI` 값**은 **-20(가장 높은 우선순위)**에서 19(가장 낮은 우선순위)까지 설정할 수 있음
- 기본적으로 새로운 프로세스를 실행하며 `NI` 값을 설정함

**① nice -10 1222, ② nice —10 1222**

- 잘못된 명령어. `nice`는 **프로세스 ID(PID)를 직접 지정**할 수 없음
- ~~우선순위를 조정하려면~~ `renice` 명령어를 사용해야 함

**③ nice -10 bash**

- 올바른 명령어
- 이 명령은 `bash`라는 이름의 새 프로세스를 **NI 값 10**으로 시작함
- 이미 실행 중인 프로세스의 우선순위는 변경할 수 없음

---

Q. 다음 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ①
> 

```
프로세스 우선순위와 관련된 항목에는 (㉠)와 (㉡)가 있다. 
(㉠)는 사용자가 명령자가 명령어를 이용해 값을 바꿀 수가 있고,
바뀐 값을 토대로 (㉡)의 값이 변경되면서 적용된다.
```

① ㉠ NI ㉡ PRI

② ㉠ PRI ㉡ NI

③ ㉠ NICE ㉡ RENICE

④ ㉠ RENICE ㉡ NICE

- PRI는 커널이 NI를 읽어서 그것에 맞게 적절하게 운영
- ps -aux나 ps ef를 통해 확인 가능
- NI (Niceness 값)와 PRI (Priority 값)는 프로세스 우선순위에 밀접하게 연관된 두 가지 개념임
    - **NI (Niceness):**
        - 사용자가 직접 설정할 수 있는 **프로세스 우선순위 조정 값**
        - 값의 범위는 -20(가장 높은 우선순위)에서 19(가장 낮은 우선순위)
        - 명령어 예: `nice` 또는 `renice`.
    - **PRI (Priority):**
        - 실제 **커널이 프로세스에 부여하는 우선순위 값**
        - **NI 값을 기준으로 계산**되며, 프로세스의 실행 스케줄에 영향을 미침
    - 사용자가 **NI** 값을 조정하면, 커널이 이를 기준으로 **PRI** 값을 재계산
    - 따라서 **NI는 사용자 설정값**, **PRI는 커널 설정값**

---

Q. 다음 중 SIGKILL 시그널에 부여된 번호값으로 알맞은 것은?

> ②
> 

① 1

② 9

③ 15

④ 20

- **SIGKILL**은 프로세스를 강제로 종료하는 데 사용되는 시그널로, 이에 대응하는 번호값은 **9**
- 이 시그널은 프로세스가 종료를 거부하거나 응답하지 않을 때 강제적으로 프로세스를 종료할 수 있는 최후의 수단

```
- SIGKILL(9): 강제 종료.
- 다른 시그널보다 우선순위가 높으며, 일반적으로 `kill -9`로 사용됨
```

- 주요 시그널 번호와 의미:
    - **1 (SIGHUP):**
        - 프로세스의 연결 끊김(종료)을 의미하며, 주로 데몬을 재로드할 때 사용.
    - **9 (SIGKILL):**
        - 프로세스를 **즉시 종료**시키는 시그널로, 프로세스가 처리할 여유가 없음.
        - **무조건적인 종료**를 보장하기 때문에, 프로세스가 종료되지 않을 때 사용하는 강제 수단.
    - **15 (SIGTERM):**
        - 프로세스 종료 요청 시그널로, 프로세스가 정상적으로 종료할 시간을 주는 일반적인 종료 방법.
    - **20 (SIGTSTP):**
        - 키보드에서 **Ctrl+Z**를 눌렀을 때 발생하며, 프로세스를 일시 정지(Suspend)함.
- 명령어 예시:
    - **SIGKILL을 이용해 프로세스 강제 종료:**
        
        ```bash
        kill -9 [PID]
        ```
        
    - **다른 시그널로 종료:**
        - SIGTERM:
        
        ```bash
        kill -15 [PID]
        
        ```
        

---

Q. 다음 중 시그널 목록 정보를 확인할 때 사용하는 명령어로 알맞은 것은?

> ②
> 

① ps

② kill

③ nohup

④ nice

- 시그널 목록 정보를 확인하려면 `kill` 명령어에 `-l` 옵션을 사용함.
- `kill -l`을 입력하면 **시그널 이름**과 **시그널 번호**의 전체 목록이 출력됨.

1. **ps**
    - 현재 실행 중인 프로세스의 목록을 확인하는 명령어.
    - 시그널과는 관련 없음.
2. **kill**
    - 프로세스에 시그널을 전달하여 특정 작업(종료, 재시작 등)을 수행하도록 요청하는 명령어.
    - `kill -l` 옵션으로 **모든 시그널의 목록과 번호**를 확인할 수 있음.
        
        ```bash
        $ kill -l
        HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM ...
        
        ```
        
3. **nohup**
    - 프로세스를 **로그아웃 이후에도 계속 실행**되도록 백그라운드에서 실행할 때 사용하는 명령어.
    - 프로세스를 끄지 않고 뒷단에서라도 돌려라. 백에서라도 계속 돌려라.
4. **nice**
    - 프로세스의 **우선순위(NI 값)**를 조정할 때 사용하는 명령어.

---

Q. cron을 이용해서 해당 스크립트를 매주 수요일 오전 4시 1분에 주기적으로 실행하려고 한다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> **④**
> 

```bash
(괄호) /etc/backup.sh
```

① 1 4 3 * *

② 4 1 3 * *

③ 4 1 * * 3

④ 1 4 * * 3

- `cron`에서 **스케줄링 형식**:
    
    ```bash
    분(0-59) 시(0-23) 일(1-31) 월(1-12) 요일(0-7)
    ```
    
    - **분**: 1
    - **시**: 4
    - **일**: `*`(모든 날짜)
    - **월**:`*`(모든 달)
    - **요일**: 3 (**수요일**)
    - `cron` 명령어에서 요일은 마지막 항목(0=일요일, 3=수요일)이며, **수요일 오전 4시 1분**에 실행되도록 설정하려면 `1 4 * * 3`을 사용한다.

① 1 4 3 * ***

- "3일(날짜)"에 실행됨. 요일과는 관련 없음.

② 4 1 3 * ***

- 시간(4시 1분)이 잘못 배치되었음.
- 또한 "3일(날짜)"에 실행됨.

**③ 4 1 * * 3**

- 시간 형식이 잘못되었음(4시 1분이 아니라 1시 4분으로 처리됨).

**④ 1 4 * * 3**

- 올바른 형식으로, **수요일 오전 4시 1분**에 실행됨.

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
특정 데몬 하나만 메모리에 상주하면서 다수의 데몬을 관리하는 방식이다.
특정 데몬이 관리하는 서비스에 대한 요청이 들어오면 관련 데몬을 실행하여 메모리에 올려주고
서비스 이용이 끝나면 메모리에서 제거하여 효율적인 관리를 수행하였다.
리눅스 커널 24 버전부터 사용되었다.
```

① inetd

② xinetd

③ init

④ systemd

- 메모리의 효율적인 관리 : inetd
    - standalone 방식 : 유저가 무슨 명령을 내릴지 모르므로 계속 데몬을 뒤에서 프로세스를 올려서 돌리는는 방식
    - inetd 방식 : 메모리의 효율이 안 좋으므로 호출하는 방식

- `xinetd`는 **슈퍼 데몬(Super Daemon)**으로, 여러 서비스 요청을 관리하는 데몬이다. 이는 `inetd`의 확장 버전이며, 보다 효율적으로 **다수의 데몬 및 서비스 관리**를 수행한다.
- 주요 특징:
    - **메모리 효율성**: 요청이 들어오면 해당 서비스를 실행하고, 사용이 끝나면 메모리에서 제거.
    - **접근 제어 및 로깅 기능 강화**: inetd에 비해 보안과 서비스 관리 기능이 개선됨.
    - 리눅스 커널 **2.4** 버전부터 사용되었다.

**① inetd**:

- 초기 슈퍼 데몬으로, 서비스 요청을 관리했으나 보안과 기능이 단순함.
- `xinetd`로 대체됨.

**② xinetd**:

- `inetd`의 개선 버전으로, 문제에서 언급된 **효율적인 서비스 관리** 및 **메모리 관리** 방식에 부합.

**③ init**:

- 초기화 데몬으로, 시스템 부팅 시 프로세스를 초기화하고 관리.
- 문제의 "다수의 데몬 관리"와 관련 없음.

**④ systemd**:

- init의 대체로 설계된 최신 시스템 관리 도구.
- 시스템 부팅 및 유닛 관리(서비스, 소켓 등)에 초점.

```
1. 메모리의 효율적인 관리 - inetd 방식
inetd(Internet Super Daemon)는 네트워크 서비스의 메모리 효율성을 높이기 위해 설계된 방식이다.
데몬을 항상 메모리에 상주시키는 방식이 아니라, 서비스 요청이 들어올 때 필요한 데몬을 실행하는 방식으로 작동한다.
예: FTP, Telnet 등 네트워크 관련 서비스.

2. Standalone 방식과 inetd 방식의 차이점
Standalone 방식:
서비스 데몬이 항상 메모리에 상주하며, 사용자가 요청할 때를 기다림.
장점: 요청에 대해 빠른 응답 가능.
단점: 여러 데몬이 항상 메모리를 차지하므로 비효율적.

inetd 방식:
서비스 요청이 있을 때만 데몬을 실행하여 메모리를 효율적으로 관리.
장점: 메모리 사용량 감소, 관리 간소화.
단점: 요청 시 데몬을 실행해야 하므로 초기 응답 속도가 다소 느릴 수 있음.

3. 한계와 개선
inetd는 초기 방식이었으며, 보안 및 기능 개선이 필요했음.
이를 해결하기 위해 xinetd가 등장.
xinetd는 inetd의 확장판으로, 보안 및 로깅 기능이 강화됨.

- Standalone 방식 → 데몬 상주로 비효율적.
- inetd 방식 → 메모리 효율적 관리.
- xinetd 방식 → inetd의 단점을 보완한 고급 슈퍼 데몬.
- inetd 방식은 Standalone 방식의 메모리 비효율성을 해결하기 위해 요청 시 데몬을 호출하여 작동하는 메모리 효율적인 방식이다.
```

---

Q. 다음 중 배시셸에서 aaa라고 입력하면 ‘ls -alF’가 실행되도록 설정하는 명령으로 알맞은 것은?

> ②
> 

① alias aaa ‘ls -alF’

② alias aaa=’ls -alF’

③ alias ‘ls -alF’ aaa

④ alias ‘ls -alF’ = aaa

- **`alias` 명령어**는 **명령어를 짧은 이름으로 대체**하거나 새로 정의할 때 사용한다.
    - 형식:
        
        ```bash
        alias [별칭]=’[실행 명령어]'
        ```
        
    - `alias aaa='ls -alF'`:
    → `aaa`를 입력하면 `ls -alF` 명령어가 실행됨.

**① alias aaa ‘ls -alF’**

- 등호(=)가 없으므로 형식이 잘못됨.

**② alias aaa=’ls -alF’**

- 올바른 형식으로 별칭 설정이 가능.

**③ alias ‘ls -alF’ aaa**

- 형식이 잘못됨. `alias`는 `[별칭]=[명령어]` 구조를 사용해야 함.

**④ alias ‘ls -alF’ = aaa**

- 형식이 잘못됨. **실행 명령어를 별칭에 할당**하는 방식이 아님.

---

Q. 다음 설명에 해당하는 셸로 알맞은 것은?

> ①
> 

```
1983년 AT&T사의 벨 연구소에 근무하던 데이비드 **콘**이 개발한 셸로 본 셸을 확장해서 만들어졌다.
작업제어, 에일리어스, 히스토리 기능 등을 제공한다.
```

① **k**sh

② zsh

③ dash

④ bash

- **ksh (KornShell)**:
    - 1983년, AT&T 벨 연구소의 데이비드 콘(David Korn)이 개발.
    - 본 셸(Bourne Shell, sh)을 기반으로 하여 작업 제어, 별칭(alias), 명령어 기록(history) 등의 기능을 추가.
    - 강력한 스크립트 작성 기능과 효율성 덕분에 많은 유닉스 시스템에서 사용.

**① ksh**

- 정답. 데이비드 콘이 개발했으며 본 셸의 확장 버전이다.

**② zsh**

- Z 셸(Zsh)은 K 셸과 Bash를 결합하고 확장한 최신 셸로, **1990년대에 개발**됨.
- 본 셸의 직접적인 확장 버전은 아님.

**③ dash**

- Dash(Debian Almquist Shell)는 빠르고 가벼운 POSIX 호환 셸로, KornShell이나 본 셸의 확장과는 관련이 없음.

**④ bash**

- GNU 프로젝트에서 개발한 Bourne-Again Shell.
- 본 셸을 대체하기 위해 만들어졌으나, KornShell과는 직접적인 관계가 없음.

---

Q. 다음 결과에 해당하는 명령으로 알맞은 것은?

> ②
> 

![스크린샷 2024-11-27 오후 8.14.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/e5777a55-f20a-4de7-89c5-6cf1a4f2947b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.14.57.png)

① sh -l

② chsh -l

③ grep sh /etc/passwd

④ cat /etc/bashrc

- 주어진 출력은 시스템에 설치된 **사용 가능한 셸 목록**을 보여줌.
이와 같은 결과는 **chsh** 명령어의 `l` 옵션을 통해 확인할 수 있다.
- 내가 바꿀 수 있는 셸의 리스트를 봄

**① `sh -l`**

- `sh` 명령은 Bourne 셸을 실행.
- `l` 옵션은 로그인 셸로 실행한다는 뜻으로, 출력과는 관련이 없음.

**② `chsh -l`**

- **chsh (change shell)** 명령의 `l` 옵션은 시스템에서 사용 가능한 셸 목록을 출력함
- **정답**.

**③ `grep sh /etc/passwd`**

- `/etc/passwd` 파일에서 "sh" 문자열을 포함하는 라인을 검색하는 명령.
- passwd는 계정 정보를 가지고 있으므로 아님.

**④ `cat /etc/bashrc`**

- `/etc/bashr`는 별칭 파일.

---

Q. 다음 중 ( 괄호 ) 안에 들어갈 명령의 결과로 알맞은 것은?

> ④
> 

```bash
[ihduser@ihd ~]$ user=kaitman 
[ihduser@ihd ~]$ echo $user
( 괄호 )
```

① 아무것도 출력되지 않는다.

② $user

③ ihduser

④ kaitman

- `$user`는 변수를 사용하려고 하며, 이미 해당 변수가 선언되고 값이 할당되었음.
    
    ```bash
    user=kaitman  # 'user' 변수에 'kaitman' 값을 할당
    echo $user    # 변수 'user'의 값을 출력
    ```
    
    - `$user`는 `echo` 명령어에 의해 값을 출력합니다.
    - `user` 변수는 값으로 `kaitman`을 가지고 있으므로 출력 결과는 `kaitman`이 됨

**① 아무것도 출력되지 않는다.**

- **오답**: 변수 `user`는 이미 값이 할당되어 있으므로 값이 출력됨.

**② `$user`**

- **오답**: `$user`는 변수를 참조하는 표현이며, 변수의 값(`kaitman`)이 출력됨.

**③ ihduser**

- **오답**: `ihduser`는 현재 사용자 계정 이름일 가능성이 있지만, 이는 `$user` 변수와는 관계가 없음.

**④ kaitman**

- **정답**: `$user`는 `kaitman` 값을 가지고 있으므로 올바른 출력 결과.

---

Q. 다음 중 최근에 입력한 5개의 명령 목록을 확인하기 위한 명령으로 알맞은 것은?

> ③
> 

① !5

② !-5

③ history 5

④ history -5

- **`history`**: 셸에서 실행된 명령의 기록을 관리하고 출력하는 명령어.
- **`history [숫자]`**: 기록된 명령 중 최근 **숫자**에 해당하는 갯수만큼 출력. 따라서, `history 5`는 최근 **5개의 명령 목록**을 출력한다.

1. **① `!5`**
    - **오답**: `!5`는 **명령 기록 번호 5번**에 해당하는 명령을 **재실행**하는 명령. 최근 5개의 명령을 확인하는 목적과는 다름.
2. **② `!-5`**
    - **오답**: `!-5`는 현재 실행 중인 명령을 기준으로 **최근 5번째 명령을 재실행**하는 명령.
3. **③ `history 5`**
    - **정답**: `history 5`는 **최근 입력한 5개의 명령을 목록 형태로 확인**하는 명령.
4. **④ `history -5`**
    - **오답**: `history -5`는 잘못된 문법. `history` 명령은 `-`옵션을 사용하지 않음.

---

Q. 다음 중 시스템 전체 사용자에게 적용되는 함수(function)이나 에일리어스(alias)를 설정할 때 사용하는 파일로 가장 알맞은 것은?

> ①
> 

① /etc/bashrc

② /etc/profile

③ ~/.bashrc 

④ ~/.bash_profile

- 시스템 전체이므로 ①(bashrc)
- `.`찍힌 숨긴 파일들은 개인 사용자
- profile에는 전체에 대한 환경변수나 여러 가지 function이 들어감

1. **시스템 전체 적용 설정**:
    
    특정 사용자뿐 아니라 **시스템의 모든 사용자**에게 적용되는 설정 파일은 일반적으로 `/etc/` 디렉토리에 위치함
    
2. **파일 분석**:
    - **`/etc/profile`**:
        - 시스템 전체 사용자에게 적용되는 **환경 변수, 함수, 에일리어스** 등을 설정할 때 사용됨
        - **로그인 셸** 실행 시 적용됨
    - **`/etc/bashrc`**:
        - 시스템 전체 사용자에게 적용되지만, **비로그인 셸**을 포함한 **모든 Bash 세션**에 적용되는 설정 파일
        - 일반적으로 함수나 에일리어스를 설정하는 데 사용되기도 하지만, **주로 별도로 호출**되는 경우가 많음
    - **`~/.bashrc`**:
        - 특정 사용자에게 적용되는 **비로그인 셸**용 개인 설정 파일.
        - 사용자 별로 함수, 에일리어스 등을 설정할 때 사용됨
    - **`~/.bash_profile`**:
        - 특정 사용자에게 적용되는 **로그인 셸**용 개인 설정 파일.
        - 사용자 별 초기화 작업(환경 변수, 경로 추가 등)을 설정할 때 주로 사용됨

Q. 다음 중 root 사용자가 ihduser 사용자의 셸을 변경할 때 사용하는 명령으로 알맞은 것은?

> ①
> 

① chsh ihduser

② chsh -s ihduser

③ chsh -u ihduser

④ chsh -l ihduser

- chsh ihduser
    - chsh 계정명 -s /bin/bash
        - 셸을 바꾸겠다. 생략된 상태(나중에 옵션으로 넣을 것)

---

Q. ihduser 사용자가 계정 생성 후에 처음으로 시스템에 로그인한 상태이다. 다음 중 로그인 셸을 확인하는 방법으로 가장 거리가 먼 것은?

> ③
> 

① ps

② echo $SHELL

③ cat /etc/shells

④ grep ihduser /etc/passwd

- ps -ef나 aux하면 맨 뒤에 셸이 bin/bash 이런 식으로 나타남
- ③ 셸 전체 리스트가 보임, 로그인 셸을 확인하는 방법과 가장 거리가 멀다.
- ④ etc/passwd에서 나의 계정을 잡아오면 알 수 있음

---

Q. 다음 중 현재 마운트된 디스크의 남아있는 용량을 확인할 때 사용하는 명령어로 알맞은 것은?

> ②
> 

① fdisk

② df

③ mount

④ du

![스크린샷 2024-12-02 오후 6.50.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/73d5fce9-f6b9-42f0-8bd7-e9d57320df2d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.50.15.png)

- ① fdisk : 파티션별로 출력
    
    ![스크린샷 2024-12-02 오후 6.52.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/7ca5aca6-001e-47b2-a95d-9cff84254cc1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.52.12.png)
    
- ④ du : 디렉토리별로 출력
    
    ![스크린샷 2024-12-02 오후 6.51.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/42b28a07-5676-4b67-a6c2-44c7738b9ca9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.51.03.png)
    
    - 디렉토리별로 나옴

- **df**: 현재 마운트된 파일 시스템의 총 용량, 사용된 용량, 남아있는 용량을 보고하는 명령어다. 따라서 디스크의 남아있는 용량을 확인할 때 가장 적합한 명령어다.
- **du**: 특정 파일이나 디렉토리의 디스크 사용량을 추정하는 데 사용된다. 전체 파일 시스템의 남아있는 용량을 확인하는 데는 적합하지 않다.
- **fdisk**: 주로 디스크를 파티션하는 데 사용되는 명령어로, 디스크 공간 사용량에 대한 정보를 제공하지 않는다.
- **mount**: 파일 시스템을 마운트하거나 마운트된 상태를 확인하는 데 사용된다. 디스크 공간 정보를 제공하지 않는다.
- 따라서, 현재 마운트된 디스크의 남아있는 용량을 확인하려면 `df` 명령어를 사용하는 것이 맞다.

---

Q. 다음 설명에 해당하는 용어로 알맞은 것은?

> ③
> 

```
최근 리눅스에서는 파티션을 생성하면 고유한 이 값이 부여되고,
부팅 시에 이 값을 기반으로 마운트 작업이 진행된다.
```

① blkid

② label

③ uuid

④ vendor_id

- **UUID (Universally Unique Identifier)**: 각 파티션에 고유한 식별자를 부여하여, 시스템이 부팅 시 이 값을 기반으로 디스크를 마운트할 수 있도록 한다. UUID는 `/etc/fstab` 파일에서 사용되어 장치 이름이 변경되더라도 일관되게 파티션을 식별하고 마운트할 수 있게 한다.
- **blkid**: 이 명령어는 각 파티션의 UUID를 확인하는 데 사용된다. UUID를 직접 생성하거나 변경하는 기능은 없다.
- **label**: 파티션에 이름을 붙이는 방법으로, UUID와는 다르게 고유성을 보장하지 않는다. 주로 사람이 이해하기 쉽게 이름을 붙일 때 사용된다.
- **vendor_id**: 하드웨어 제조업체를 식별하는 ID로, 파티션이나 디스크의 고유 식별자와는 관련이 없다.

---

Q. 다음 중 파일이나 디렉터리 생성 시 부여되는 기본 허가권을 확인하는 명령어로 알맞은 것은?

> ④
> 

① ls

② chmod

③ chown

④ umask

![스크린샷 2024-12-02 오후 7.10.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/abde76ef-158a-4f43-80b1-76226c5e46d2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.10.06.png)

![스크린샷 2024-12-02 오후 7.08.36.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/e71ca4c4-bd7d-41ad-ac1f-47aa6ecb08ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.08.36.png)

- ls -l : 리스트를 long form으로 보여준다.(-l=long)
- 디렉터리 생성 시 부여되는 기본 허가권값을 조회하는 것이 ls, 확인하는 명령어는 umask이다.

- 파일이나 디렉터리 생성 시 부여되는 기본 허가권을 확인하는 명령어는 **④ umask이다.**
- **umask**: 이 명령어는 새로 생성되는 파일이나 디렉터리의 기본 권한을 설정하는 데 사용된다. `umask` 값은 시스템의 기본 권한에서 빼는 방식으로 작동하여, 새로 생성되는 파일과 디렉터리에 적용할 기본 권한을 결정한다. 예를 들어, 일반적으로 파일의 기본 권한은 666, 디렉터리는 777이며, `umask` 값이 022일 경우 파일은 644, 디렉터리는 755 권한으로 생성된다.(생성시 조건)
    
    ![스크린샷 2024-12-02 오후 7.19.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/2e58697b-1008-4297-a0ff-2116c4858287/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.19.35.png)
    
- **ls**: 파일이나 디렉터리의 목록을 보여주는 명령어로, 기본 허가권을 설정하거나 확인하는 기능은 없다.
- **chmod**: 기존 파일이나 디렉터리의 권한을 변경하는 데 사용된다.(허가권 변경)
- **chown**: 파일이나 디렉터리의 소유자 및 그룹을 변경하는 명령어다.(소유권 변경)
- 따라서, 파일이나 디렉터리가 생성될 때의 기본 권한을 확인하려면 `umask` 명령어를 사용해야 한다.

---

Q. 다음 중 시스템에 장착된 디스크나 USB 메모리에 분할된 파티션 정보를 확인할 때 사용하는 명령으로 알맞은 것은?

> ①
> 

① fdisk -l

② df -h

③ mount

④ du -sh

![스크린샷 2024-12-02 오후 7.42.00.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/e4bdadec-ae20-4d76-a81a-72dc4b5b99ff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.42.00.png)

- fdisk -l: 이 명령어는 시스템에 연결된 디스크의 파티션 테이블을 표시한다. `-l` 옵션은 모든 디스크의 파티션 정보를 나열하여, 각각의 파티션이 어떻게 분할되어 있는지를 보여준다. 이 명령어는 디스크의 파티션 상태를 확인하고 관리하는 데 유용하다.
- df -h: 파일 시스템의 사용량과 남은 용량을 확인하는 명령어로, 각 파일 시스템의 크기와 사용 가능한 공간을 표시하지만, 파티션 정보는 제공하지 않는다
- mount: 현재 마운트된 파일 시스템을 나열하거나 새로운 파일 시스템을 마운트하는 데 사용된다. 파티션 자체의 정보를 제공하지는 않는다.
- du -sh: 특정 디렉터리의 디스크 사용량을 요약하여 보여주는 명령어로, 파티션 정보와는 관련이 없다.

---

Q. 다음 중 /etc/fstab 파일의 세 번째 필드 정보로 알맞은 것은?

> ②
> 

① 마운트 시에 적용되는 옵션

② 파일 시스템 유형

③ 마운트 디렉터리

④ 파일 시스템 점검 유무

![스크린샷 2024-12-02 오후 7.57.09.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/c17e1711-de09-4e00-8cbb-19225ab8bf2d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.57.09.png)

![스크린샷 2024-12-02 오후 7.47.59.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/dee233b8-3860-475f-b1c9-8f68e45904ac/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.47.59.png)

![스크린샷 2024-12-02 오후 7.49.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/8c5b7f27-940e-472d-8fc4-6fb911c1dd5d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.49.14.png)

- 장치명, 마운트 될 디렉터리 위치, 타입(파일 시스템 유형), 옵션, 점검 유무
- **파일 시스템 유형 (②)**: `/etc/fstab` 파일의 세 번째 필드는 마운트될 파일 시스템의 유형을 지정합니다. 일반적으로 `ext4`, `xfs`, `ntfs`와 같은 파일 시스템 형식이 이 필드에 들어간다.
- **마운트 시에 적용되는 옵션 (①)**: 네 번째 필드에 해당하며, 파일 시스템을 마운트할 때 사용할 옵션들을 지정한다. 예를 들어, `defaults`, `ro`, `rw` 등이 있다.
- **마운트 디렉터리 (③)**: 두 번째 필드에 해당하며, 파일 시스템이 마운트될 디렉터리 경로를 지정한다.
- **파일 시스템 점검 유무 (④)**: 여섯 번째 필드에 해당하며, 부팅 시 파일 시스템 점검을 수행할지를 결정하는 옵션이다. 일반적으로 0, 1, 2로 설정된다.

---

Q. 다음은 ihduser 사용자가 본인에게 설정된 디스크 쿼터 정보를 확인하는 과정이다. ( 괄호 ) 안에 들어갈 명령어로 알맞은 것은?

> ①
> 

```bash
[ihduser@ihd ~]$ (괄호)
```

① quota

② edquota

③ setquota

④ repquota

- quota 계정 혹은 repquota 디렉터리가 온다.
- **quota**: 사용자가 본인에게 설정된 디스크 쿼터 정보를 확인할 때 사용하는 명령어다. 이 명령어를 통해 사용자는 자신의 디스크 사용량과 할당된 쿼터의 상태를 확인할 수 있다.
- **edquota**: 사용자의 디스크 쿼터를 편집할 때 사용하는 명령어로, 주로 시스템 관리자가 특정 사용자나 그룹의 쿼터 설정을 변경할 때 사용한다.
- **setquota**: 특정 사용자나 그룹의 쿼터를 설정하는 명령어다. 주로 시스템 관리자가 쿼터의 제한을 설정할 때 사용한다.
- **repquota**: 시스템 전체의 쿼터 사용 현황을 요약하여 보여주는 명령어로, 주로 시스템 관리자가 전체적인 쿼터 상태를 점검할 때 사용한다.

---

Q. 다음 중 chmod 명령어 사용법으로 틀린 것은?

> ③
> 

① chmod a= lin.txt

② chmod u+s hack.sh

③ chmod g+t data/

④ chmod o+t data/

- Sticky-bit는 그룹에 설정 X
- ① chmod u+s a.out: 이 명령어는 `a.out` 파일에 대해 Set-UID 비트를 설정한다. 이는 파일이 실행될 때 파일 소유자의 권한으로 실행되도록 한다.
- ② chmod g+s a.out: 이 명령어는 `a.out` 파일에 대해 Set-GID 비트를 설정한다. 이는 파일이 실행될 때 그룹 소유자의 권한으로 실행되도록 한다.
- ③ chmod o+t /project: 이 명령어는 `/project` 디렉터리에 Sticky Bit를 설정한다. Sticky Bit는 디렉터리 내의 파일을 소유자나 루트 사용자만 삭제할 수 있도록 한다.
- ④ chmod g+t /project: Sticky Bit는 주로 `o+t`로 설정하며, 그룹에 대해서는 적용되지 않는다.

![스크린샷 2024-12-02 오후 8.06.27.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/36b3f78d-afc4-4a4f-8ac5-ac6e209ca1b6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.06.27.png)

- 리눅스에서, 파일(File)을 사용해 할 수 있는 작업은 크게 세 가지로 나눌 수 있다.
    - 파일에 저장된 데이터를 읽기. (r = read).
    - 파일에 데이터를 쓰기. (w = write).
    - 파일 실행. (x = execute)
- chmod 다음에 "선택 옵션"과 "모드를 나타내는 문자열", 그리고 "대상 파일(또는 디렉토리)"을 순서대로 입력하여 파일의 모드를 변경할 수 있다.
    
    ![스크린샷 2024-12-02 오후 8.07.40.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/3bb6cae4-79fc-4da7-aa3d-f796d81808a6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.07.40.png)
    
- "ls -l" 명령을 실행하면, 현재 디렉토리 내 파일 리스트(ls=list)가 하나의 파일 단위로 한줄로 길게(-l=long) 표시되는데, 공백 기준으로 가장 첫 번째 항목(-rw-r--r--)이 파일 소유자 별 권한, 세 번째(ppotta)와 네 번째(manager) 항목이 각각 파일 소유자와 그룹을 나타낸다.
    
    ![스크린샷 2024-12-02 오후 8.13.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/e6a7c9d1-2a89-4aa0-806c-8408be71ea64/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.13.11.png)
    
- 앞서 실행한 "ls -l" 명령의 실행 결과를 해석하면, 그 결과는 아래와 같다.
    
    ![스크린샷 2024-12-02 오후 8.13.53.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/dc1cf687-f599-4ece-a177-edbfb7c8da5a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.13.53.png)
    
- **chmod** 명령은 바로 이러한 파일의 권한을 변경할 수 있게 만들어주는 명령이다. "**ch**ange"와 "**mod**e"의 앞 글자들을 조합한 이름이다.(chmod = ch + mod)

---

Q. 다음 중 디렉터리에 부여되는 x(execute) 권한에 대한 설명으로 알맞은 것은?

> ②
> 

① ls 명령을 사용해서 디렉터리 안에 있는 파일 목록을 볼 수 있다.

② cd 명령을 사용해서 디렉터리 안으로 들어갈 수 있다.

③ 디렉터리 안에 있는 실행 파일을 실행할 수 있다.

④ 디렉터리 안에 실행 파일을 생성할 수 있다.

- **②** 디렉토리에 실행(x) 권한이 부여되면 사용자는 `cd` 명령어를 사용하여 해당 디렉토리로 이동할 수 있다. 실행 권한은 디렉토리에 접근할 수 있도록 허용하는 기본적인 권한이다.
- **① ls 명령을 사용해서 디렉터리 안에 있는 파일 목록을 볼 수 있다**: 읽기(r) 권한과 관련이 있다. 읽기 권한이 있어야 `ls` 명령어로 디렉토리 내의 파일 목록을 볼 수 있다.
- **③ 디렉터리 안에 있는 실행 파일을 실행할 수 있다**: 파일에 대한 실행(x) 권한과 관련된 설명이다. 디렉토리의 실행 권한은 파일 실행과 직접적인 관련이 없다.
- **④ 디렉토리 안에 실행 파일을 생성할 수 있다**: 쓰기(w) 권한과 관련이 있다. 쓰기 권한이 있어야 디렉토리에 파일을 생성하거나 삭제할 수 있다.

---

Q. XFS 파일 시스템 기반의 서버를 운영하고 있다. 다음 중 이 서버의 파일 시스템을 점검하는 방법으로 가장 알맞은 것은?

> ③
> 

① fsck 명령을 이용해서 점검한다.

② e2fsck 명령을 이용해서 점검한다.

③ xfs_repair 명령을 이용해서 점검한다.

④ btrfs-check 명령을 이용해서 점검한다.

- **xfs_repair**: XFS 파일 시스템의 손상이나 오류를 점검하고 복구하는 데 사용되는 명령어다. XFS 파일 시스템은 다른 파일 시스템과 달리 부팅 시 자동으로 fsck가 실행되지 않기 때문에, 문제가 발생했을 때 수동으로 `xfs_repair`를 실행해야 한다. 이 명령어는 파일 시스템이 마운트되지 않았거나 읽기 전용으로 마운트된 상태에서만 작동한다.
- **fsck**: 일반적인 파일 시스템 검사 도구이지만, XFS 파일 시스템에는 직접 사용할 수 없다. XFS는 자체적인 검사 및 복구 도구인 `xfs_repair`를 사용해야 합니다.(file system check)
- **e2fsck**: ext2/ext3/ext4 파일 시스템을 위한 검사 및 복구 도구로, XFS와는 관련이 없다.
- **btrfs-check**: Btrfs 파일 시스템을 위한 검사 도구로, XFS와는 관련이 없다.

---

Q. 다음과 같이 허가권이 설정된 경우에 관련 설명으로 알맞은 것은?

> ④
> 

```bash
[root@www ~]# ls -l /usr/bin/passwd
-rwsr-xr-x. 1 root root 27856 Apr 1 2020 /usr/bin/passwd
```

① 이 파일은 root 사용자만이 실행할 수 있다.

② ihduser 사용자가 실행하면 ihduser 사용자 권한으로 실행된다.

③ ihduser 사용자가 실행하면 실행하는 동안 root 그룹 권한으로 인정된다.

④ ihduser 사용자가 실행하면 실행하는 동안 root 사용자 권한으로 인정된다.

- UserID에 StickyBit가 세팅되어 있다. 따라서, Set-UID 비트에 의해 `passwd` 명령어는 일반 사용자가 실행하더라도 root 권한으로 동작하게 된다.
- 파일 `/usr/bin/passwd`의 허가권 설정에 대한 설명으로 알맞은 것은 **④ ihduser 사용자가 실행하면 실행하는 동안 root 사용자 권한으로 인정된다**이다.
- **Set-UID 비트 (`s`)**: 파일의 소유자 권한으로 프로그램이 실행되도록 설정하는 특수 권한이다. `/usr/bin/passwd` 파일은 `rwsr-xr-x`로 설정되어 있으며, 이는 Set-UID 비트가 설정되어 있음을 나타낸다. 따라서, 이 파일을 실행하는 사용자는 파일 소유자의 권한, 즉 root 권한으로 프로그램을 실행하게 된다.
- **① 이 파일은 root 사용자만이 실행할 수 있다**: 파일의 실행 권한은 모든 사용자에게 (`r-x`) 부여되어 있다.
- **② ihduser 사용자가 실행하면 ihduser 사용자 권한으로 실행된다**: Set-UID 비트 때문에 root 권한으로 실행된다.
- **③ ihduser 사용자가 실행하면 실행하는 동안 root 그룹 권한으로 인정된다**: Set-GID 비트가 아닌 Set-UID 비트가 설정되어 있으므로 그룹 권한이 아닌 사용자 권한이 적용된다.

---

Q. 다음 설명에 해당하는 용어로 알맞은 것은?

> ②
> 

```
2009년 2월 BMW, 델파이, GM, 윈드리버 등이 설립하여 만든 리눅스 운영체제 기반의 표준화된 자동차용 IVI 플랫폼이다.
```

① QNX

② GENIVI

③ webOS

④ Tizen

- **GENIVI**: GENIVI는 2009년 2월에 BMW, 델파이, GM, 윈드리버 등이 설립하여 만든 리눅스 운영체제 기반의 표준화된 자동차용 IVI(In-Vehicle Infotainment) 플랫폼이다. 이 플랫폼은 차량 인포테인먼트 시스템의 오픈 소스 개발과 규격화를 목표로 하는 비영리 협의체로, 자동차 산업에서 널리 사용되는 레퍼런스 플랫폼을 제공한다.
- **QNX**: 실시간 운영체제로, 주로 임베디드 시스템에서 사용되며, IVI 플랫폼으로도 사용되지만 GENIVI와는 다른 제품이다.(유닉스)
- **webOS**: 원래 스마트폰용으로 개발된 운영체제로, LG에 의해 스마트 TV 등 다양한 기기에 사용되고 있다.(LG와 하고 있는 리눅스)
- **Tizen**: 리눅스 재단이 주도하는 오픈 소스 운영체제로, 모바일 기기와 가전제품 등 다양한 분야에서 사용된다.(삼성과 하는 리눅스)

---

Q. 다음 중 CPU 전가상화 및 반가상화를 모두 지원하는 가상화 기술로 알맞은 것은?

> ①
> 

① Xen

② KVM

③ Docker

④ VirtualBox

- 반가상화까지 지원하는 것은 Xen
- **Xen**: Xen은 전가상화(Full Virtualization)와 반가상화(Paravirtualization)를 모두 지원하는 하이퍼바이저이다. Xen은 하드웨어 가상화 기술(Intel VT, AMD-V)을 활용하여 전가상화를 구현할 수 있으며, 또한 반가상화를 통해 성능을 최적화할 수 있는 기능도 제공한다.
- **KVM**: 주로 전가상화를 지원하는 하이퍼바이저로, 하드웨어 가상화 기술을 필요로 한다.
- **Docker**: 컨테이너 기반의 가상화 기술로, 전통적인 의미의 하드웨어 가상화와는 다르다.
    - 이미지 컨테이너, 쿠버네티스
- **VirtualBox**: 주로 전가상화를 지원하는 데스크톱 가상화 소프트웨어다.

---

Q. 다음 중 슈퍼컴퓨터와 같이 빠른 수치 연산이 필요한 경우에 구축하는 시스템으로 알맞은 것은?

> ③
> 

① LVS Cluster

② HA Cluster

③ HPC Cluster

④ Load Balance Cluster

- **HPC Cluster (High-Performance Computing Cluster)**: 고성능 컴퓨팅(HPC) 클러스터는 여러 대의 컴퓨터(노드)로 구성되어 복잡한 계산 작업을 고속으로 수행하는 시스템이다. 이러한 클러스터는 병렬 컴퓨팅을 활용하여 대규모 데이터를 처리하고 복잡한 문제를 해결하는 데 사용된다. HPC 클러스터는 슈퍼컴퓨터와 유사한 역할을 하며, 과학 연구, 엔지니어링, 시뮬레이션, 데이터 분석 등 다양한 분야에서 활용된다.
- **LVS Cluster**: 주로 네트워크 로드 밸런싱을 위한 클러스터로, 수치 연산보다는 네트워크 트래픽 관리에 중점을 둔다.
    - LVS는 **Linux Virtual Server**의 약자로, 고가용성과 고성능을 제공하기 위해 여러 대의 서버를 클러스터로 묶어 하나의 가상 서버처럼 동작하도록 하는 기술이다. LVS는 주로 로드 밸런싱을 통해 여러 서버에 걸쳐 트래픽을 분산시켜 서비스의 신뢰성과 성능을 향상시키는 데 사용된다. 이 시스템은 활성 LVS 라우터와 백업 LVS 라우터로 구성되어 있으며, 활성 라우터는 실제 서버들 간의 부하를 분산하고 각 서버의 서비스 상태를 점검하는 역할을 한다.
- **HA Cluster (High Availability Cluster)**: 시스템의 가용성을 높이기 위해 설계된 클러스터로, 장애 발생 시 서비스가 중단되지 않도록 하는 데 중점을 둔다.(고가용성)
- **Load Balance Cluster**: 여러 서버에 걸쳐 작업 부하를 분산시켜 효율성을 높이는 클러스터로, 주로 웹 서버와 같은 환경에서 사용된다.

---

Q. 다음 설명에 해당하는 프로그램으로 알맞은 것은?

> ③
> 

```
리눅스 재단의 하위 재단인 CNCF(Cloud Native Computing Foundation)에서 개발하는 오픈소스 프로젝트로
컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화해준다.
```

① Docker

② Openstack

③ Kubernetes

④ Ansible

- **Kubernetes**: Kubernetes는 리눅스 재단의 하위 재단인 CNCF(Cloud Native Computing Foundation)에서 개발하는 오픈소스 프로젝트로, **컨테이너화된 애플리케이션(Docker)**의 배포, 확장, 관리를 자동화하는 플랫폼이다. 이 기술은 컨테이너 오케스트레이션을 통해 대규모의 컨테이너를 효율적으로 관리할 수 있도록 설계되었으며, 자동화된 배포, 확장, 롤백 기능을 제공한다.
- **Docker**: Docker는 컨테이너를 생성하고 관리하는 데 사용되는 플랫폼으로, Kubernetes와 함께 사용되어 컨테이너의 배포 및 관리를 수행한다.
- **Openstack**: Openstack은 클라우드 인프라를 구축하고 관리하기 위한 오픈소스 소프트웨어로, 주로 IaaS(Infrastructure as a Service)를 제공하는 데 사용된다.
- **Ansible**: Ansible은 IT 자동화를 위한 도구로, 서버 설정 및 애플리케이션 배포를 자동화하는 데 사용된다. ㄴ

---

Q. 다음 중 이더넷 카드에 연결된 케이블의 상태를 확인할 수 있는 명령어로 알맞은 것은?

> ④
> 

① route

② arp

③ ifconfig

④ ethtool

- **ethtool**: 이 명령어는 네트워크 인터페이스의 하드웨어 설정을 확인하고 변경하는 데 사용된다. 특히, 이더넷 카드에 연결된 케이블의 상태, 속도, 듀플렉스 모드 등을 확인할 수 있다. `ethtool`을 사용하면 네트워크 인터페이스의 물리적 연결 상태를 점검할 수 있어 케이블 문제를 진단하는 데 유용하다.
- **route**: 네트워크 라우팅 테이블을 보여주거나 수정하는 명령어로, 케이블 상태와는 관련이 없다.
- **arp**: ARP(Address Resolution Protocol) 캐시를 보여주거나 수정하는 명령어로, 네트워크 인터페이스의 물리적 상태를 확인할 수 없다.
- **ifconfig**: 네트워크 인터페이스의 설정을 보여주거나 변경하는 명령어로, 기본적으로 케이블의 물리적 상태를 직접 확인하지는 않는다.

---

Q. 다음 중 전자 메일과 가장 거리가 먼 프로토콜로 알맞은 것은?

> ②
> 

① POP3

② SNMP

③ SMTP

④ IMAP

![스크린샷 2024-12-03 오후 7.53.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/d031e84a-4e93-4b20-b749-4be224e18f0e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.53.21.png)

![스크린샷 2024-12-03 오후 7.52.58.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/483fea58-f255-4eb4-8010-db7f44cc45d2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.52.58.png)

- **SNMP(Simple Network Management Protocol)**: 네트워크 장치를 모니터링하고 관리하기 위한 인터넷 표준 프로토콜로, 라우터, 스위치, 서버 등의 네트워크 장치를 관리하는 데 사용된다. 전자 메일 송수신과는 직접적인 관련이 없다.
- 다른 프로토콜들의 전자 메일 관련 기능:
    - **IMAP**: 이메일을 서버에 저장하고 동기화하는 프로토콜(받았을 때, 포트번호 143)
    - **POP3**: 이메일을 서버에서 클라이언트로 다운로드하는 프로토콜(받았을 때 확인, 포트번호 110)
    - **SMTP**: 이메일을 송신하는 프로토콜(보낼 때, 포트번호 25)

---

Q. 다음 중 OSI 7계층 모델에서 물리 계층의 데이터 전송 단위로 알맞은 것은?

> ④
> 

① frame

② packet

③ socket

④ bit

- **bit**: 물리 계층(Physical Layer)은 데이터를 0과 1의 비트 형태로 전송한다. 이 계층은 전기적, 기계적, 물리적 특성에 집중하여, 네트워크 케이블과 같은 물리 매체를 통해 비트를 전송하는 역할을 한다.
- **frame**: 데이터 링크 계층(Data Link Layer)에서 사용되는 데이터 단위.
- **packet**: 네트워크 계층(Network Layer)에서 사용되는 데이터 단위.
- **socket**: 네트워크 연결을 위한 소프트웨어 인터페이스로, 특정 계층의 데이터 전송 단위가 아니다.

- 물데네전세표응
    - bit frame packet segmet
    - 물리계층은 리피터
    - 물리계층과 데이터링크 계층을 묶는 것은  브릿지
        - 데이터링크 계층엔 MAC 주소
    - 네트워크엔 라우터

---

Q. 다음에서 설명하는 네트워크 종류로 알맞은 것은?

> ②
> 

```
국가, 대륙 등과 같은 넓은 지역을 연결하는 네트워크이다.
거리상의 제약이 없지만 다양한 경로를 경유해서 도달하므로 속도가 느리고 전송 에러율도 높다.
```

① MAN 

② WAN

③ LAN

④ X.25

- **① MAN (Metropolitan Area Network)**: 도시 규모의 지역을 연결하는 네트워크로, 일반적으로 도시나 대도시권 내의 여러 LAN을 연결한다.
- **② WAN (Wide Area Network)**: 국가, 대륙 등과 같은 넓은 지역을 연결하는 네트워크이다. WAN은 다양한 경로를 경유하여 데이터를 전송하므로 속도가 느리고 전송 에러율이 높을 수 있다. WAN은 여러 LAN을 연결하여 광범위한 지역에 걸쳐 네트워크를 형성한다.
- **③ LAN (Local Area Network)**: 좁은 지역, 예를 들어 한 건물이나 캠퍼스 내에서 사용되는 네트워크다. 속도가 빠르고 에러율이 낮다.
- **④ X.25**: 오래된 패킷 교환 네트워크 프로토콜로, 주로 공공 데이터망에서 사용되었다. 현재는 거의 사용되지 않는다.

---

Q. 다음 설명에 해당하는 프로토콜로 알맞은 것은?

> ③
> 

```
세그먼트를 보내기만 하고 응답을 주고받지 않는 프로토콜이어서 
제대로 전달되었는지 확인하지 않으며 오류 수정도 하지 않는다.
```

① TCP

② IP

③ UDP

④ HTTP

- **① TCP (Transmission Control Protocol)**: 연결 지향형 프로토콜로, 데이터 전송 전에 연결을 설정하고, 데이터가 제대로 전달되었는지 확인하며 오류를 수정한다. 따라서 세그먼트의 전달 여부를 확인하고 오류 수정 기능이 있다.
- **② IP (Internet Protocol)**: 네트워크 계층에서 사용되는 프로토콜로, 데이터 패킷을 목적지까지 전달하는 역할을 한다. IP 자체는 데이터의 전송 여부를 확인하거나 오류 수정을 하지 않는다.
- **③ UDP (User Datagram Protocol)**: 비연결형 프로토콜로, 데이터를 보내기만 하고 수신 여부를 확인하지 않으며 오류 수정도 하지 않는다. UDP는 빠른 전송이 필요하지만 데이터의 신뢰성이 덜 중요한 경우에 사용된다.
- **④ HTTP (Hypertext Transfer Protocol)**: 웹에서 데이터를 주고받기 위해 사용되는 프로토콜로, 기본적으로 TCP 위에서 동작하여 데이터의 신뢰성을 보장한다.

---

Q. 다음 설명에 해당하는 도메인으로 알맞은 것은?

> ④
> 

```
비영리 목적의 기관이나 단체 등에서 사용할 수 있다.
```

① com

② mil

③ int

④ org

- **① com**: 주로 상업적 목적으로 사용되는 도메인이다. 기업이나 사업체가 주로 사용한다.(company, 삼성닷컴)
- **② mil**: 군사 기관에서 사용하는 도메인이다. 주로 미국 군대와 관련된 사이트에서 사용된다.(밀리터리)
- **③ int**: 국제 기구에서 사용하는 도메인이다. 예를 들어, 국제연합과 같은 국제적인 조직에서 사용된다.(인터내셔널)
- **④ org**: 비영리 목적의 기관이나 단체에서 주로 사용하는 도메인이다. 이 도메인은 비영리 단체, 자선 단체, 문화 및 종교 기관 등에서 신뢰성과 무결성을 나타내기 위해 사용된다. org 도메인은 비영리적 가치와 공익을 상징하며, 이러한 조직들이 온라인에서 권위 있는 이미지를 구축하는 데 도움을 준다.
    
    ![스크린샷 2024-12-03 오후 11.27.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/0f9a337f-b348-402b-9329-66e6287686a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.27.03.png)
    
    ![스크린샷 2024-12-03 오후 11.28.36.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e2d8e2b-4ab3-463b-b14f-cbdd834a0993/5f7356b3-57d4-4381-8c12-6635ad0f4506/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-12-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.28.36.png)
    

---

Q. 다음 설명에 해당하는 국제기구로 알맞은 것은?

> ②
> 

```
전기 및 전자공학 분야의 전문가로 구성된 국제조직으로
컴퓨터 네트워크 분야의 LAN 및 MAN 관련 표준을 제정하였다.
```

① ISO

② IEEE

③ ITU

④ ANSI

- **① ISO (International Organization for Standardization)**: 다양한 산업 분야에서 국제 표준을 개발하고 발행하는 기구이다.
- **② IEEE (Institute of Electrical and Electronics Engineers)**: 전기 및 전자공학 분야의 전문가로 구성된 국제조직으로, 특히 IEEE 802 LAN/MAN Standards Committee를 통해 LAN 및 MAN 관련 표준을 제정한다. 이 표준에는 Ethernet, Wireless LAN, Wireless MAN 등이 포함된다.
- **③ ITU (International Telecommunication Union)**: 국제 전기통신 연합으로, 주로 전 세계 통신 표준과 규제를 담당하지만, LAN 및 MAN의 세부적인 표준 제정은 IEEE가 주로 담당한다.
- **④ ANSI (American National Standards Institute)**: 미국의 국가 표준을 개발하고 조정하는 기구로, 국제적인 네트워크 표준 제정보다는 미국 내 표준화에 초점을 맞추고 있다.

---

Q. 다음 설명에 해당하는 프로토콜로 알맞은 것은?

> ④
> 

```
메시지에 대한 오류 보고와 이에 대한 피드백을 원래 호스트에 보고하는 역할을 수행한다.
ping 명령이 사용하는 프로토콜이다.
```

① IP 

② ARP

③ UDP

④ ICMP

이 문제는 메시지에 대한 오류 보고와 피드백을 원래 호스트에 보고하는 역할을 수행하며, `ping` 명령이 사용하는 프로토콜을 묻고 있습니다

- **① IP (Internet Protocol)**: 데이터 패킷을 네트워크를 통해 전송하는 역할을 하지만, 오류 보고 및 피드백 기능은 없다.
- **② ARP (Address Resolution Protocol)**: IP 주소를 물리적 하드웨어 주소로 변환하는 프로토콜로, 오류 보고와는 관련이 없다.
- **③ UDP (User Datagram Protocol)**: 비연결형 프로토콜로, 데이터의 신뢰성을 보장하지 않으며 오류 보고 기능이 없다.
- **④ ICMP (Internet Control Message Protocol)**: 네트워크 계층에서 오류 메시지와 운영 정보를 전송하는 데 사용되는 프로토콜이다. ICMP는 네트워크 문제를 진단하고 오류를 보고하는 데 사용되며, `ping` 명령어가 이 프로토콜을 사용하여 네트워크 연결 상태를 확인한다.