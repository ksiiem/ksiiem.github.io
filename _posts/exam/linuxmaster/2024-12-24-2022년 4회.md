---
title: "[Linux] 2022년 4회"
categories: [Study, OS]
---

# [1과목] 리눅스 운영 및 관리

---

Q. 다음 중 프린터 작업 큐의 상태 정보를 확인할 때 사용하는 명령으로 알맞은 것은?

> ③
> 

① lp

② lpr

③ lpstat

④ cancel

- 큐의 상태 정보
    - lp = line print
    - stat = status
- lp, lpr
    - 프린터 출력
    

---

Q. 다음 중 원격지 시스템에 있는 프린터를 공유할 때 사용할 수 있는 서비스로 알맞은 것은?

> ④
> 

① OSS

② NFS

③ SANE

④ SAMBA

- 프린터 공유는 SAMBA
- ① 사운드 관련
- ② Network File System - 네트워크 상에서 파일이나 폴더 공유
- ③ 스캐너 관련

---

Q. 다음 설명의 경우 구성하면 좋은 기술로 가장 알맞은 것은?

> ①
> 

```
사용자가 많아져서 디스크의 용량이 부족할 때 손쉽게 용량 증설이 가능하기를 원한다.
```

① LVM

② RAID

③ SAMBA

④ NFS

- Logical Volume Management
    - 물리적으로 붙이고 논리적으로 인식
- ② 복구 기술
- ③ 리눅스와 윈도우 시스템 간의 파일이나 프린터 공유

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ②
> 

```
1998년에 시작된 프로젝트로 사운드카드를 자동으로 구성하게 하고, 사운드 장치 **관리**를 목적으로 하고 있다. 현재 GPL 및 LGPL 라이선스 기반으로 배포되고 있다.
```

① OSS

② ALSA

③ SANE

④ LPRng

- ① **오픈 사운드 시스템**(Open Sound System, OSS)은 유닉스 및 유닉스 계열 운영 체제의 사운드를 만들고 캡처하는 인터페이스이다.(사운드 따는 기술)
- ② **고급 리눅스 사운드 아키텍처**(Advanced Linux Sound Architecture, ALSA)는 리눅스 커널의 구성 요소 중 하나로 [사운드 카드](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%B4%EB%93%9C_%EC%B9%B4%EB%93%9C)용 장치 드라이버를 위한 API를 제공하는 소프트웨어 프레임워크이다. ALSA는 오픈 사운드 시스템(OSS)에서 고안 당시 지원하지 못했던 몇가지 다음 기능들을 포함하여 설계되었다.(사운드 관리)
- ③ SANE은 스캐너
- ④ 프린터

---

Q. 다음 중 CUPS 프린팅 시스템 **설정** 및 제어할 때 사용하는 명령으로 가장 알맞은 것은?

> ④
> 

① lpc

② lpr

③ lpq

④ lpadmin

- **CUPS**(Common Unix Printing System, 공식 명칭으로 CUPS가 더 자주 쓰임)는 컴퓨터를 인쇄 서버로 기능하도록 해주는 유닉스 계열 운영 체제를 위한 모듈 방식의 프린팅 시스템이다. 컵스(CUPS)는 애플에서 개발한 오픈 소스 형태의 프린터 관련 소프트웨어이다.
- line print admin(설정)

---

Q. 다음 중 10GB 용량을 가진 디스크 5개를 사용해서 RAID-6를 구성했을 경우 실제 사용 가능한 디스크 용량으로 알맞은 것은?

> ③
> 

① 10GB

② 20GB

③ 30GB

④ 40GB

- RAID5의 경우, 손실 비율 33%
- 10*5의 30%는 15%이므로 15GB 이상이 손실 → 35GB → 35GB에서 줄어들 것이므로 30GB

---

Q. 다음은 현재 디렉터리 안에 텍스트 파일을 하나의 파일로 묶는 과정이다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

```bash
# tar (괄호) text.tar *.txt
```

① cvf

② xvf

③ tvf

④ rvf

- 추가할 때는 r 옵션
- 하나로 묶을 때는 c 옵션
- t는 조회
- x는 푸는 옵션

---

Q. 다음 중 yum 명령을 이용해서 nmap 패키지를 설치하는 명령으로 알맞은 것은?

> ②
> 

① yum nmap install

② yum install nmap

③ yum -i nmap

④ yum -y nmap

- ③ 묻지 않고 yes로 진행

---

Q. 다음 설명에 해당하는 설치 과정으로 알맞은 것은?

> ①
> 

```
Makefile 파일에 저장된 내용을 반영하고, 타깃(target)과 의존성(Dependencies) 관련 작업을 한 후에 최종적으로 실행 파일을 만든다.
```

① make

② configure

③ make install

④ make clean

---

Q. 다음 중 파일의 크기가 가장 작은 압축 형식으로 알맞은 것은?

> ②
> 

① php-8.1.7.tar.gz

② php-8.1.7.tar.xz

③ php-8.1.7.tar.bz2

④ php-8.1.7.tar.Z

- xz, bz2, gz, z(compress) 순서로 효율 좋음

---

Q. 다음 (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/1.png)

① -q

② -Q

③ -v

④ -V

- S.5....T.는 vsftpd를 verify 검증한다는 것

---

Q. 다음 중 온라인 패키지 관리 기법으로 틀린 것은?

> ①
> 

① dnf

② yum

③ apt-get

④ YaST

- 기본 패키지 관리와 온라인의 디펜던시 문제까지 해결해주는 방법이 있음
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/2.png)
    
    - 레드햇 계열 : rpm / yum 을 사용
    - 우분투 계열 : dpkg(데비안 패키지) / apt+get 을 사용
    - 수세 계열: YaST / zypper

---

Q. 다음 중 우분투 리눅스에서 패키지를 설치하는 방법으로 가장 알맞은 것은?

> ③
> 

① rpm 명령을 이용해서 설치한다.

② yum 명령을 이용해서 설치한다.

③ apt-get 명령을 이용해서 설치한다.

④ zypper 명령을 이용해서 설치한다.

---

Q. 다음 중 일반적인 cmake 설치 과정으로 알맞은 것은?

> ①
> 

① cmake → make install

② configure → cmake → make install

③ cmake → configure → make install

④ make → cmake → make install

- cmake(cross platform make) : 빌드 파일을 생성해주는 프로그램
- 일반적인 방법은  configure → make → make install
    
    

---

Q. 다음 중 vi 편집기에서 복사한 내용을 붙여넣기 할 때 사용하는 키로 알맞은 것은?

> ①
> 

① P

② yy

③ dd

④ s

- p : copy
- dd : delete

---

Q. vi 편집기를 이용해서 문서 작업 중에 중단되어서 작업하던 내용을 불러오려고 한다. ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/3.png)

① -c

② -r

③ -R

④ +

---

Q. 다음 중 vi 편집기에서 **줄의 시작**이 linux인 경우에만 전부 Linux로 치환하는 명령으로 알맞은 것은?

> ①
> 

① :% s/^linux/Linux/

② :% s/\<linux/Linux/

③ :% s/\<linux\>/Linux/

④ “% s/linux/Linux/

- 줄의 시작은 ^(carrot)

---

Q. 다음 중 리눅스에 사용되는 편집기에 대한 설명으로 틀린 것은?

> ①
> 

① nano 편집기가 개선되어서 등장한 것이 pico 편집기이다.

② vi 편집기가 개선되어서 등장한 것이 vim 편집기이다.

③ vi 편집기는 빌 조이가 개발하였다.

④ emacs는 리처드 스톨만이 개발하였다.

- **pico와 nano**
    - **nano**: 기존의 **pico** 편집기를 개선한 텍스트 편집기(pico → nano)
    - 주요 개선: 더 많은 기능과 유연성을 제공
- **빌 조이 (Bill Joy)**
    - Unix와 관련된 여러 소프트웨어 도구를 개발한 컴퓨터 과학자
    - 대표적인 업적: **vi 편집기**의 창시자
- **emacs**
    - **Lisp 언어**를 활용하기에 적합한 텍스트 편집기
    - 주요 기능: 강력한 **치환(문자 대체)** 및 **질의 기능** 지원
- **리누스 토르발스 (Linus Torvalds)**
    - **Linux 운영체제**의 창시자
    - 오픈소스 소프트웨어의 상징적 인물

---

Q. 다음 중 **X 윈도 기반**으로 실행되는 편집기 조합으로 알맞은 것은?

> ④
> 

① gedit, pico

② pico, nano

③ gedit, nano

④ gedit, kwrite

- X윈도 기반은 GUI(graphical) 환경
    - GUI를 구현해줄 수 있는 환경이 X윈도
        - **X 윈도 기반** 편집기란, 그래픽 사용자 인터페이스(GUI) 환경에서 동작하는 텍스트 편집기를 의미함. 이는 X Window System 위에서 실행되며, 터미널 기반이 아닌 그래픽 창을 제공하는 편집기들이다.
        - **gedit**: GNOME 데스크톱 환경에서 사용하는 기본 텍스트 편집기. X 윈도 기반으로 동작
        - **kwrite**: KDE 데스크톱 환경에서 제공하는 GUI 텍스트 편집기. 역시 X 윈도 기반
- 리눅스는 주로 CLI  환경

- **① gedit, pico**:
    - **gedit**는 X 윈도 기반이지만, **pico**는 터미널 기반 편집기
- **② pico, nano**:
    - 둘 다 터미널 기반으로 실행. X 윈도와는 무관함
- **③ gedit, nano**:
    - **gedit**는 X 윈도 기반이지만, **nano**는 터미널 기반

---

Q. 다음 중 emacs 편집기에서 커서의 위치를 현재 커서가 위치한 행의 끝으로 이동하는 조합으로 알맞은 것은?

> ②
> 

① [Ctrl] + [a]

② [Ctrl] + [e]

③ [Ctrl] + [c]

④ [Ctrl] + [x]

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/4.png)

- **[Ctrl] + [e]**: Emacs 편집기에서 **커서를 현재 행의 끝으로 이동**하는 단축키
    - **e**는 'end'를 연상할 수 있어, 행의 끝으로 이동하는 기능을 나타냄
- 다른 옵션:
    - **① [Ctrl] + [a]**: 커서를 **현재 행의 시작으로 이동** (a = beginning of line)
    - **② [Ctrl] + [c]**: **명령 실행**을 위한 단축키 조합의 일부로 사용됨 (e.g., [Ctrl] + [c] followed by 다른 키)
    - **③ [Ctrl] + [x]**: **Emacs 명령 모드**로 전환하거나 명령어 실행을 위한 접두 키로 사용됨

---

Q. 실행 중인 모든 프로세스의 정보를 출력할 때 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ②
> 

```bash
# ps ( 괄호 )
```

① ef

② aux

③ -al

④ -f

- `ps` 명령어는 시스템에서 실행 중인 프로세스 정보를 출력하는 유틸리티. 옵션에 따라 출력되는 정보의 범위와 상세 수준이 달라짐
- **ps aux**:이 명령은 **모든 프로세스** 정보를 출력하는 데 널리 사용됨
    - `a`: 터미널에 종속되지 않은 모든 사용자 프로세스를 포함함
    - `u`: 프로세스를 소유한 사용자 및 CPU/메모리 사용량 등의 정보를 보여줌
    - `x`: 터미널을 갖지 않은 백그라운드 프로세스를 포함함
    - **결과적으로**, 실행 중인 **모든 프로세스** 정보를 표시하는 가장 일반적인 방식임
- **① ef**:
    - `ps ef`는 유효하지 않다. 그러나 `ps -ef`라면 **표준 형식으로 모든 프로세스 정보를 출력**함. `aux`보다 덜 상세한 정보 형식임
- **③ -al**:
    - `ps -al`은 현재 사용자와 관련된 프로세스를 **자세히 출력**. 하지만 **모든 사용자**의 프로세스를 출력하지는 않음
- **④ -f**:
    - `ps -f`는 **현재 사용자의 프로세스를 포맷 형식으로 출력**

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
하나의 프로세스가 다른 프로세스를 실행할 때 사용하는 시스템 호출 방법의 하나로서,
새롭게 생성된 프로세스는 호출한 프로세스의 자식 프로세스가 된다.
```

① exec

② fork

③ init

④ systemd

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/5.png)

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/6.png)

- `fork`는 프로세스 생성에 사용되는 **시스템 호출**로, 기존 프로세스(부모 프로세스)가 새로운 프로세스(자식 프로세스)를 생성하는 데 사용됨
    - 부모 프로세스는 `fork`를 호출하여 자신과 동일한 복사본을 생성함
    - 새로운 프로세스는 **자식 프로세스**로 간주됨
    - 이 호출의 결과로 부모와 자식은 **동시에 실행**되며, **자식 프로세스는 부모 프로세스의 주소 공간을 복사**받음
- **① exec**:
    - `exec`는 **현재 프로세스를 종료**하고 새로운 프로세스를 실행하는 시스템 호출
    - `fork`와는 다르게 프로세스 자체를 교체하며, 새로운 프로세스를 생성하지는 않음
- **③ init**:
    - `init`은 시스템 부팅 시 가장 먼저 실행되는 **최초의 프로세스**
    - 모든 다른 프로세스는 `init`의 자식 프로세스. 새로운 프로세스를 생성하는 호출 방식은 아님
- **④ systemd**:
    - `systemd`는 현대 리눅스 시스템에서 사용되는 **시스템 및 서비스 관리 데몬**
    - `init`의 대체로 개발되었으며, 프로세스를 생성하거나 관리하는 기능을 수행하지만, `fork`와는 다름

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ③
> 

```
보통 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다려야 하는데, 이러한 프로세스를 일컫는 용어이다.
```

① exec 프로세스

② fork 프로세스

③ 포어그라운드(Foreground) 프로세스

④ 백그라운드(Background) 프로세스

- 백그라운드는 기다리지 않고 다른 작업 가능, 포어그라운드는 기다려야 함
- **포어그라운드(Foreground) 프로세스**는 **셸에서 실행된 명령어를 바로 처리하는 프로세스**
    - 사용자가 셸에서 명령을 입력하면 프로세스가 실행되고, 해당 프로세스가 종료될 때까지 셸은 **다른 작업을 받지 않고 대기 상태**가 됨
    - 예를 들어, 터미널에서 `ls`나 `vim` 명령을 실행하면, 결과가 나올 때까지 사용자는 다른 명령을 실행할 수 없음
- **① exec 프로세스**:
    - `exec`는 **현재 프로세스를 새로운 프로세스로 대체**하는 시스템 호출
    - 셸의 실행 대기와는 관련이 없음
- **② fork 프로세스**:
    - `fork`는 **부모 프로세스에서 자식 프로세스를 복사해 생성**하는 시스템 호출
    - 명령 실행과 대기 상태보다는 프로세스 생성과 관련이 있음
- **④ 백그라운드(Background) 프로세스**:
    - 백그라운드 프로세스는 실행 중에도 셸이 명령 입력을 받을 수 있어, **셸을 차단하지 않음**
    - 이는 셸 명령 뒤에 `&`를 붙여 실행(예: `sleep 10 &`)하면 나타남

---

Q. 다음 중 백그라운드로 동작 중인 프로세스를 확인할 때 사용하는 명령어로 알맞은 것은?

> ③
> 

① fg

② bg

③ jobs

④ nohup

- **`jobs` 명령어**란?
    - **현재 셸에서 실행 중인 백그라운드 및 정지된 프로세스를 확인**할 때 사용하는 명령어
- `jobs`를 입력하면 작업 번호, 상태(정지, 실행 중), 명령 등을 확인할 수 있음
- 주로 **백그라운드 프로세스 관리**에 사용됨

- **① fg**:
    - **백그라운드 작업을 포어그라운드로 전환**하는 명령어
    - `fg %작업번호` 형식으로 사용하며, `jobs` 명령으로 확인한 작업 번호를 사용함
- **② bg**:
    - 정지된 작업을 **백그라운드에서 계속 실행**하게 만드는 명령어
- **④ nohup**:
    - **셸이 종료되어도 프로세스가 계속 실행되도록 만드는 명령어**
    - 예: `nohup ./my_script.sh &`
    - 백그라운드 작업 확인보다는 프로세스 지속성에 초점이 있음

- 백그라운드에서 실행 중인 프로세스를 **확인**하려면 **`jobs`** 명령어를 사용함
- `fg`, `bg`는 프로세스를 관리하거나 상태를 변경할 때 사용됨

---

Q. 프로세스 아이디(PID)가 1222인 bash 프로세스의 우선순위(NI)값이 0이다. 다음 중 이 프로세스의 NI값을 10으로 변경하는 명령으로 알맞은 것은?

> ③
> 

① nice -10 1222

② nice —10 1222

③ nice -10 bash

④ nice —10 bash

- 프로세스 우선순위 값을 변경할 때 PID가 아닌 프로세스명으로 함
- renice는 프로세스ID 사용
- nice는 -20~19의 범위
    - -20 : 최강 → 무조건 실행(마이너스, 극강으로 priority 올려줌)
    - 19 : 실행 천천히 가능

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/7.png)

- `nice` 명령은 프로세스의 **우선순위(NI, Niceness 값)**를 조정할 때 사용됨
- **`NI` 값**은 **-20(가장 높은 우선순위)**에서 19(가장 낮은 우선순위)까지 설정할 수 있음
- 기본적으로 새로운 프로세스를 실행하며 `NI` 값을 설정함

- **① nice -10 1222, ② nice —10 1222**
    - 잘못된 명령어. `nice`는 **프로세스 ID(PID)를 직접 지정**할 수 없음
    - `renice` 명령어를 사용해야 함
- **③ nice -10 bash**
    - 올바른 명령어. 이 명령은 `bash`라는 이름의 새 프로세스를 **NI 값 10**으로 시작함
    - 이미 실행 중인 프로세스의 우선순위는 변경할 수 없음

---

Q. 다음 ( 괄호 ) 안에 들어갈 내용으로 알맞은 것은?

> ①
> 

```
프로세스 우선순위와 관련된 항목에는 (㉠)와 (㉡)가 있다. 
(㉠)는 사용자가 명령자가 명령어를 이용해 값을 바꿀 수가 있고,
바뀐 값을 토대로 (㉡)의 값이 변경되면서 적용된다.
```

① ㉠ NI ㉡ PRI

② ㉠ PRI ㉡ NI

③ ㉠ NICE ㉡ RENICE

④ ㉠ RENICE ㉡ NICE

- PRI는 커널이 NI를 읽어서 그것에 맞게 적절하게 운영
- ps -aux나 ps ef를 통해 확인 가능
- NI (Niceness 값)와 PRI (Priority 값)는 프로세스 우선순위에 밀접하게 연관된 두 가지 개념임
    - **NI (Niceness):**
        - 사용자가 직접 설정할 수 있는 **프로세스 우선순위 조정 값**
        - 값의 범위는 -20(가장 높은 우선순위)에서 19(가장 낮은 우선순위)
        - 명령어 예: `nice` 또는 `renice`
    - **PRI (Priority):**
        - 실제 **커널이 프로세스에 부여하는 우선순위 값**
        - **NI 값을 기준으로 계산**되며, 프로세스의 실행 스케줄에 영향을 미침
    - 사용자가 **NI** 값을 조정하면, 커널이 이를 기준으로 **PRI** 값을 재계산
    - 따라서 **NI는 사용자 설정값**, **PRI는 커널 설정값**

---

Q. 다음 중 SIGKILL 시그널에 부여된 번호값으로 알맞은 것은?

> ②
> 

① 1

② 9

③ 15

④ 20

- **SIGKILL**은 프로세스를 강제로 종료하는 데 사용되는 시그널로, 이에 대응하는 번호값은 **9**
- 이 시그널은 프로세스가 종료를 거부하거나 응답하지 않을 때 강제적으로 프로세스를 종료할 수 있는 최후의 수단

```
- SIGKILL(9): 강제 종료.
- 다른 시그널보다 우선순위가 높으며, 일반적으로 `kill -9`로 사용됨
```

- 주요 시그널 번호와 의미:
    - **1 (SIGHUP):**
        - 프로세스의 연결 끊김(종료)을 의미하며, 주로 데몬을 재로드할 때 사용
    - **9 (SIGKILL):**
        - 프로세스를 **즉시 종료**시키는 시그널로, 프로세스가 처리할 여유가 없음
        - **무조건적인 종료**를 보장하기 때문에, 프로세스가 종료되지 않을 때 사용하는 강제 수단
    - **15 (SIGTERM):**
        - 프로세스 종료 요청 시그널로, 프로세스가 정상적으로 종료할 시간을 주는 일반적인 종료 방법
    - **20 (SIGTSTP):**
        - 키보드에서 **Ctrl+Z**를 눌렀을 때 발생하며, 프로세스를 일시 정지(Suspend)함
- 명령어 예시:
    - **SIGKILL을 이용해 프로세스 강제 종료:**
        
        ```bash
        kill -9 [PID]
        ```
        
    - **다른 시그널로 종료:**
        - SIGTERM:
        
        ```bash
        kill -15 [PID]
        ```
        

---

Q. 다음 중 시그널 목록 정보를 확인할 때 사용하는 명령어로 알맞은 것은?

> ②
> 

① ps

② kill

③ nohup

④ nice

- 시그널 목록 정보를 확인하려면 `kill` 명령어에 `-l` 옵션을 사용함
- `kill -l`을 입력하면 **시그널 이름**과 **시그널 번호**의 전체 목록이 출력됨

- **① ps**
    - 현재 실행 중인 프로세스의 목록을 확인하는 명령어
    - 시그널과는 관련 없음
- **② kill**
    - 프로세스에 시그널을 전달하여 특정 작업(종료, 재시작 등)을 수행하도록 요청하는 명령어
    - `kill -l` 옵션으로 **모든 시그널의 목록과 번호**를 확인할 수 있음
        
        ```bash
        	$ kill -l
        HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM ...
        
        ```
        
- **③ nohup**
    - 프로세스를 **로그아웃 이후에도 계속 실행**되도록 백그라운드에서 실행할 때 사용하는 명령어
    - 프로세스를 끄지 않고 뒷단에서라도 돌려라. 백에서라도 계속 돌려라
- **④ nice**
    - 프로세스의 **우선순위(NI 값)**를 조정할 때 사용하는 명령어

---

Q. cron을 이용해서 해당 스크립트를 매주 수요일 오전 4시 1분에 주기적으로 실행하려고 한다. (괄호) 안에 들어갈 내용으로 알맞은 것은?

> **④**
> 

```bash
(괄호) /etc/backup.sh
```

① 1 4 3 * *

② 4 1 3 * *

③ 4 1 * * 3

④ 1 4 * * 3

- `cron`에서 **스케줄링 형식**:
    
    ```bash
    분(0-59) 시(0-23) 일(1-31) 월(1-12) 요일(0-7)
    ```
    
    - **분**: 1
    - **시**: 4
    - **일**: `*`(모든 날짜)
    - **월**:`*`(모든 달)
    - **요일**: 3 (**수요일**)
    - `cron` 명령어에서 요일은 마지막 항목(0=일요일, 3=수요일)이며, **수요일 오전 4시 1분**에 실행되도록 설정하려면 `1 4 * * 3`을 사용한다.

- ① 1 4 3 * ***
    - "3일(날짜)"에 실행됨. 요일과는 관련 없음
- ② 4 1 3 * ***
    - 시간(4시 1분)이 잘못 배치되었음
    - 또한 "3일(날짜)"에 실행됨
- **③ 4 1 * * 3**
    - 시간 형식이 잘못되었음(4시 1분이 아니라 1시 4분으로 처리됨)
- **④ 1 4 * * 3**
    - 올바른 형식으로, **수요일 오전 4시 1분**에 실행됨

---

Q. 다음 설명에 해당하는 명칭으로 가장 알맞은 것은?

> ②
> 

```
특정 데몬 하나만 메모리에 상주하면서 다수의 데몬을 관리하는 방식이다.
특정 데몬이 관리하는 서비스에 대한 요청이 들어오면 관련 데몬을 실행하여 메모리에 올려주고
서비스 이용이 끝나면 메모리에서 제거하여 효율적인 관리를 수행하였다.
리눅스 커널 24 버전부터 사용되었다.
```

① inetd

② xinetd

③ init

④ systemd

- 메모리의 효율적인 관리 : inetd
    - standalone 방식 : 유저가 무슨 명령을 내릴지 모르므로 계속 데몬을 뒤에서 프로세스를 올려서 돌리는는 방식
    - inetd 방식 : 메모리의 효율이 안 좋으므로 호출하는 방식

- `xinetd`는 **슈퍼 데몬(Super Daemon)**으로, 여러 서비스 요청을 관리하는 데몬이다. 이는 `inetd`의 확장 버전이며, 보다 효율적으로 **다수의 데몬 및 서비스 관리**를 수행한다.
- 주요 특징:
    - **메모리 효율성**: 요청이 들어오면 해당 서비스를 실행하고, 사용이 끝나면 메모리에서 제거
    - **접근 제어 및 로깅 기능 강화**: inetd에 비해 보안과 서비스 관리 기능이 개선됨
    - 리눅스 커널 **2.4** 버전부터 사용되었다.

**① inetd**:

- 초기 슈퍼 데몬으로, 서비스 요청을 관리했으나 보안과 기능이 단순함
- `xinetd`로 대체됨

**② xinetd**:

- `inetd`의 개선 버전으로, 문제에서 언급된 **효율적인 서비스 관리** 및 **메모리 관리** 방식에 부합

**③ init**:

- 초기화 데몬으로, 시스템 부팅 시 프로세스를 초기화하고 관리
- 문제의 "다수의 데몬 관리"와 관련 없음

**④ systemd**:

- init의 대체로 설계된 최신 시스템 관리 도구
- 시스템 부팅 및 유닛 관리(서비스, 소켓 등)에 초점

```
1. 메모리의 효율적인 관리 - inetd 방식
inetd(Internet Super Daemon)는 네트워크 서비스의 메모리 효율성을 높이기 위해 설계된 방식이다.
데몬을 항상 메모리에 상주시키는 방식이 아니라, 서비스 요청이 들어올 때 필요한 데몬을 실행하는 방식으로 작동한다.
예: FTP, Telnet 등 네트워크 관련 서비스.

2. Standalone 방식과 inetd 방식의 차이점
Standalone 방식:
서비스 데몬이 항상 메모리에 상주하며, 사용자가 요청할 때를 기다림.
장점: 요청에 대해 빠른 응답 가능.
단점: 여러 데몬이 항상 메모리를 차지하므로 비효율적.

inetd 방식:
서비스 요청이 있을 때만 데몬을 실행하여 메모리를 효율적으로 관리.
장점: 메모리 사용량 감소, 관리 간소화.
단점: 요청 시 데몬을 실행해야 하므로 초기 응답 속도가 다소 느릴 수 있음.

3. 한계와 개선
inetd는 초기 방식이었으며, 보안 및 기능 개선이 필요했음.
이를 해결하기 위해 xinetd가 등장.
xinetd는 inetd의 확장판으로, 보안 및 로깅 기능이 강화됨.

- Standalone 방식 → 데몬 상주로 비효율적.
- inetd 방식 → 메모리 효율적 관리.
- xinetd 방식 → inetd의 단점을 보완한 고급 슈퍼 데몬.
- inetd 방식은 Standalone 방식의 메모리 비효율성을 해결하기 위해 요청 시 데몬을 호출하여 작동하는 메모리 효율적인 방식이다.
```

---

Q. 다음 중 배시셸에서 aaa라고 입력하면 ‘ls -alF’가 실행되도록 설정하는 명령으로 알맞은 것은? 

> ②
> 

① alias aaa ‘ls -alF’

② alias aaa=’ls -alF’

③ alias ‘ls -alF’ aaa

④ alias ‘ls -alF’ = aaa

- **`alias` 명령어**는 **명령어를 짧은 이름으로 대체**하거나 새로 정의할 때 사용한다.
    - 형식:
        
        ```bash
        alias [별칭]=’[실행 명령어]'
        ```
        
    - `alias aaa='ls -alF'`:
    → `aaa`를 입력하면 `ls -alF` 명령어가 실행됨

- **① alias aaa ‘ls -alF’**
    - 등호(=)가 없으므로 형식이 잘못됨
- **② alias aaa=’ls -alF’**
    - 올바른 형식으로 별칭 설정이 가능
- **③ alias ‘ls -alF’ aaa**
    - 형식이 잘못됨. `alias`는 `[별칭]=[명령어]` 구조를 사용해야 함
- **④ alias ‘ls -alF’ = aaa**
    - 형식이 잘못됨. **실행 명령어를 별칭에 할당**하는 방식이 아님

---

Q. 다음 설명에 해당하는 셸로 알맞은 것은?

> ①
> 

```
1983년 AT&T사의 벨 연구소에 근무하던 데이비드 **콘**이 개발한 셸로 본 셸을 확장해서 만들어졌다.
작업제어, 에일리어스, 히스토리 기능 등을 제공한다.
```

① **k**sh

② zsh

③ dash

④ bash

- **ksh (KornShell)**:
    - 1983년, AT&T 벨 연구소의 데이비드 콘(David Korn)이 개발
    - 본 셸(Bourne Shell, sh)을 기반으로 하여 작업 제어, 별칭(alias), 명령어 기록(history) 등의 기능을 추가
    - 강력한 스크립트 작성 기능과 효율성 덕분에 많은 유닉스 시스템에서 사용
- **① ksh**
    - 정답. 데이비드 콘이 개발했으며 본 셸의 확장 버전이다.
- **② zsh**
    - Z 셸(Zsh)은 K 셸과 Bash를 결합하고 확장한 최신 셸로, **1990년대에 개발**됨
    - 본 셸의 직접적인 확장 버전은 아님
- **③ dash**
    - Dash(Debian Almquist Shell)는 빠르고 가벼운 POSIX 호환 셸로, KornShell이나 본 셸의 확장과는 관련이 없음
- **④ bash**
    - GNU 프로젝트에서 개발한 Bourne-Again Shell
    - 본 셸을 대체하기 위해 만들어졌으나, KornShell과는 직접적인 관계가 없음

---

Q. 다음 결과에 해당하는 명령으로 알맞은 것은?

> ②
> 

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/8.png)

① sh -l

② chsh -l

③ grep sh /etc/passwd

④ cat /etc/bashrc

- 주어진 출력은 시스템에 설치된 **사용 가능한 셸 목록**을 보여줌
이와 같은 결과는 **chsh** 명령어의 `l` 옵션을 통해 확인할 수 있다.
- 내가 바꿀 수 있는 셸의 리스트를 봄

- **① `sh -l`**
    - `sh` 명령은 Bourne 셸을 실행
    - `l` 옵션은 로그인 셸로 실행한다는 뜻으로, 출력과는 관련이 없음
- **② `chsh -l`**
    - **chsh (change shell)** 명령의 `l` 옵션은 시스템에서 사용 가능한 셸 목록을 출력함
    - **정답**
- **③ `grep sh /etc/passwd`**
    - `/etc/passwd` 파일에서 "sh" 문자열을 포함하는 라인을 검색하는 명령
    - passwd는 계정 정보를 가지고 있으므로 아님
- **④ `cat /etc/bashrc`**
    - `/etc/bashr`는 별칭 파일

---

Q. 다음 중 ( 괄호 ) 안에 들어갈 명령의 결과로 알맞은 것은?

> ④
> 

```bash
[ihduser@ihd ~]$ user=kaitman 
[ihduser@ihd ~]$ echo $user
( 괄호 )
```

① 아무것도 출력되지 않는다.

② $user

③ ihduser

④ kaitman

- `$user`는 변수를 사용하려고 하며, 이미 해당 변수가 선언되고 값이 할당되었음
    
    ```bash
    user=kaitman  # 'user' 변수에 'kaitman' 값을 할당
    echo $user    # 변수 'user'의 값을 출력
    ```
    
    - `$user`는 `echo` 명령어에 의해 값을 출력함
    - `user` 변수는 값으로 `kaitman`을 가지고 있으므로 출력 결과는 `kaitman`이 됨

- **① 아무것도 출력되지 않는다.**
    - **오답**: 변수 `user`는 이미 값이 할당되어 있으므로 값이 출력됨
- **② `$user`**
    - **오답**: `$user`는 변수를 참조하는 표현이며, 변수의 값(`kaitman`)이 출력됨
- **③ ihduser**
    - **오답**: `ihduser`는 현재 사용자 계정 이름일 가능성이 있지만, 이는 `$user` 변수와는 관계가 없음
- **④ kaitman**
    - **정답**: `$user`는 `kaitman` 값을 가지고 있으므로 올바른 출력 결과

---

Q. 다음 중 최근에 입력한 5개의 명령 목록을 확인하기 위한 명령으로 알맞은 것은?

> ③
> 

① !5

② !-5

③ history 5

④ history -5

- **`history`**: 셸에서 실행된 명령의 기록을 관리하고 출력하는 명령어
- **`history [숫자]`**: 기록된 명령 중 최근 **숫자**에 해당하는 갯수만큼 출력. 따라서, `history 5`는 최근 **5개의 명령 목록**을 출력한다.

- **① `!5`**
    - **오답**: `!5`는 **명령 기록 번호 5번**에 해당하는 명령을 **재실행**하는 명령. 최근 5개의 명령을 확인하는 목적과는 다름
- **② `!-5`**
    - **오답**: `!-5`는 현재 실행 중인 명령을 기준으로 **최근 5번째 명령을 재실행**하는 명령
- **③ `history 5`**
    - **정답**: `history 5`는 **최근 입력한 5개의 명령을 목록 형태로 확인**하는 명령
- **④ `history -5`**
    - **오답**: `history -5`는 잘못된 문법. `history` 명령은 `-`옵션을 사용하지 않음

---

Q. 다음 중 시스템 전체 사용자에게 적용되는 함수(function)이나 에일리어스(alias)를 설정할 때 사용하는 파일로 가장 알맞은 것은?

> ①
> 

① /etc/bashrc

② /etc/profile

③ ~/.bashrc 

④ ~/.bash_profile

- 시스템 전체이므로 ①(bashrc)
- `.`찍힌 숨긴 파일들은 개인 사용자
- profile에는 전체에 대한 환경변수나 여러 가지 function이 들어감

---

Q. 다음 중 root 사용자가 ihduser 사용자의 셸을 변경할 때 사용하는 명령으로 알맞은 것은?

> ①
> 

① chsh ihduser

② chsh -s ihduser

③ chsh -u ihduser

④ chsh -l ihduser

- chsh ihduser
    - chsh 계정명 -s /bin/bash
        - 셸을 바꾸겠다. 생략된 상태(나중에 옵션으로 넣을 것)

---

Q. ihduser 사용자가 계정 생성 후에 처음으로 시스템에 로그인한 상태이다. 다음 중 로그인 셸을 확인하는 방법으로 가장 거리가 먼 것은?

> ③
> 

① ps

② echo $SHELL

③ cat /etc/shells

④ grep ihduser /etc/passwd

- ps -ef나 aux하면 맨 뒤에 셸이 bin/bash 이런 식으로 나타남
- ③ 셸 전체 리스트가 보임, 로그인 셸을 확인하는 방법과 가장 거리가 멀다.
- ④ etc/passwd에서 나의 계정을 잡아오면 알 수 있음

---

Q. 다음 중 현재 마운트된 디스크의 남아있는 용량을 확인할 때 사용하는 명령어로 알맞은 것은?

> ②
> 

① fdisk

② df

③ mount

④ du

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/9.png)

- ① fdisk : 파티션별로 출력
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/10.png)
    
- ④ du : 디렉토리별로 출력
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/11.png)
    
    - 디렉토리별로 나옴

- **df**: 현재 마운트된 파일 시스템의 총 용량, 사용된 용량, 남아있는 용량을 보고하는 명령어다. 따라서 디스크의 남아있는 용량을 확인할 때 가장 적합한 명령어다.
- **du**: 특정 파일이나 디렉토리의 디스크 사용량을 추정하는 데 사용된다. 전체 파일 시스템의 남아있는 용량을 확인하는 데는 적합하지 않다.
- **fdisk**: 주로 디스크를 파티션하는 데 사용되는 명령어로, 디스크 공간 사용량에 대한 정보를 제공하지 않는다.
- **mount**: 파일 시스템을 마운트하거나 마운트된 상태를 확인하는 데 사용된다. 디스크 공간 정보를 제공하지 않는다.
- 따라서, 현재 마운트된 디스크의 남아있는 용량을 확인하려면 `df` 명령어를 사용하는 것이 맞다.

---

Q. 다음 설명에 해당하는 용어로 알맞은 것은?

> ③
> 

```
최근 리눅스에서는 파티션을 생성하면 고유한 이 값이 부여되고,
부팅 시에 이 값을 기반으로 마운트 작업이 진행된다.
```

① blkid

② label

③ uuid

④ vendor_id

- **UUID (Universally Unique Identifier)**: 각 파티션에 고유한 식별자를 부여하여, 시스템이 부팅 시 이 값을 기반으로 디스크를 마운트할 수 있도록 한다. UUID는 `/etc/fstab` 파일에서 사용되어 장치 이름이 변경되더라도 일관되게 파티션을 식별하고 마운트할 수 있게 한다.
- **blkid**: 이 명령어는 각 파티션의 UUID를 확인하는 데 사용된다. UUID를 직접 생성하거나 변경하는 기능은 없다.
- **label**: 파티션에 이름을 붙이는 방법으로, UUID와는 다르게 고유성을 보장하지 않는다. 주로 사람이 이해하기 쉽게 이름을 붙일 때 사용된다.
- **vendor_id**: 하드웨어 제조업체를 식별하는 ID로, 파티션이나 디스크의 고유 식별자와는 관련이 없다.

---

Q. 다음 중 파일이나 디렉터리 생성 시 부여되는 기본 허가권을 확인하는 명령어로 알맞은 것은?

> ④
> 

① ls

② chmod

③ chown

④ umask

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/12.png)

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/13.png)

- ls -l : 리스트를 long form으로 보여준다.(-l=long)
- 디렉터리 생성 시 부여되는 기본 허가권값을 조회하는 것이 ls, 확인하는 명령어는 umask이다.

- 파일이나 디렉터리 생성 시 부여되는 기본 허가권을 확인하는 명령어는 **④ umask이다.**
- **umask**: 이 명령어는 새로 생성되는 파일이나 디렉터리의 기본 권한을 설정하는 데 사용된다. `umask` 값은 시스템의 기본 권한에서 빼는 방식으로 작동하여, 새로 생성되는 파일과 디렉터리에 적용할 기본 권한을 결정한다. 예를 들어, 일반적으로 파일의 기본 권한은 666, 디렉터리는 777이며, `umask` 값이 022일 경우 파일은 644, 디렉터리는 755 권한으로 생성된다.(생성시 조건)
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/14.png)
    
- **ls**: 파일이나 디렉터리의 목록을 보여주는 명령어로, 기본 허가권을 설정하거나 확인하는 기능은 없다.
- **chmod**: 기존 파일이나 디렉터리의 권한을 변경하는 데 사용된다.(허가권 변경)
- **chown**: 파일이나 디렉터리의 소유자 및 그룹을 변경하는 명령어다.(소유권 변경)
- 따라서, 파일이나 디렉터리가 생성될 때의 기본 권한을 확인하려면 `umask` 명령어를 사용해야 한다.

---

Q. 다음 중 시스템에 장착된 디스크나 USB 메모리에 분할된 파티션 정보를 확인할 때 사용하는 명령으로 알맞은 것은?

> ①
> 

① fdisk -l

② df -h

③ mount

④ du -sh

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/15.png)

- fdisk -l: 이 명령어는 시스템에 연결된 디스크의 파티션 테이블을 표시한다. `-l` 옵션은 모든 디스크의 파티션 정보를 나열하여, 각각의 파티션이 어떻게 분할되어 있는지를 보여준다. 이 명령어는 디스크의 파티션 상태를 확인하고 관리하는 데 유용하다.
- df -h: 파일 시스템의 사용량과 남은 용량을 확인하는 명령어로, 각 파일 시스템의 크기와 사용 가능한 공간을 표시하지만, 파티션 정보는 제공하지 않는다.
- mount: 현재 마운트된 파일 시스템을 나열하거나 새로운 파일 시스템을 마운트하는 데 사용된다. 파티션 자체의 정보를 제공하지는 않는다.
- du -sh: 특정 디렉터리의 디스크 사용량을 요약하여 보여주는 명령어로, 파티션 정보와는 관련이 없다.

---

Q. 다음 중 /etc/fstab 파일의 세 번째 필드 정보로 알맞은 것은?

> ②
> 

① 마운트 시에 적용되는 옵션

② 파일 시스템 유형

③ 마운트 디렉터리

④ 파일 시스템 점검 유무

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/16.png)

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/17.png)

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/18.png)

- 장치명, 마운트 될 디렉터리 위치, 타입(파일 시스템 유형), 옵션, 점검 유무
- **파일 시스템 유형 (②)**: `/etc/fstab` 파일의 세 번째 필드는 마운트될 파일 시스템의 유형을 지정한다. 일반적으로 `ext4`, `xfs`, `ntfs`와 같은 파일 시스템 형식이 이 필드에 들어간다.
- **마운트 시에 적용되는 옵션 (①)**: 네 번째 필드에 해당하며, 파일 시스템을 마운트할 때 사용할 옵션들을 지정한다. 예를 들어, `defaults`, `ro`, `rw` 등이 있다.
- **마운트 디렉터리 (③)**: 두 번째 필드에 해당하며, 파일 시스템이 마운트될 디렉터리 경로를 지정한다.
- **파일 시스템 점검 유무 (④)**: 여섯 번째 필드에 해당하며, 부팅 시 파일 시스템 점검을 수행할지를 결정하는 옵션이다. 일반적으로 0, 1, 2로 설정된다.

---

Q. 다음은 ihduser 사용자가 본인에게 설정된 디스크 쿼터 정보를 확인하는 과정이다. ( 괄호 ) 안에 들어갈 명령어로 알맞은 것은?

> ①
> 

```bash
[ihduser@ihd ~]$ (괄호)
```

① quota

② edquota

③ setquota

④ repquota

- quota 계정 혹은 repquota 디렉터리가 온다.
- **quota**: 사용자가 본인에게 설정된 디스크 쿼터 정보를 확인할 때 사용하는 명령어다. 이 명령어를 통해 사용자는 자신의 디스크 사용량과 할당된 쿼터의 상태를 확인할 수 있다.
- **edquota**: 사용자의 디스크 쿼터를 편집할 때 사용하는 명령어로, 주로 시스템 관리자가 특정 사용자나 그룹의 쿼터 설정을 변경할 때 사용한다.
- **setquota**: 특정 사용자나 그룹의 쿼터를 설정하는 명령어다. 주로 시스템 관리자가 쿼터의 제한을 설정할 때 사용한다.
- **repquota**: 시스템 전체의 쿼터 사용 현황을 요약하여 보여주는 명령어로, 주로 시스템 관리자가 전체적인 쿼터 상태를 점검할 때 사용한다.

---

Q. 다음 중 chmod 명령어 사용법으로 틀린 것은?

> ③
> 

① chmod a= lin.txt

② chmod u+s hack.sh

③ chmod g+t data/

④ chmod o+t data/

- Sticky-bit는 그룹에 설정 X
- ① chmod u+s a.out: 이 명령어는 `a.out` 파일에 대해 Set-UID 비트를 설정한다. 이는 파일이 실행될 때 파일 소유자의 권한으로 실행되도록 한다.
- ② chmod g+s a.out: 이 명령어는 `a.out` 파일에 대해 Set-GID 비트를 설정한다. 이는 파일이 실행될 때 그룹 소유자의 권한으로 실행되도록 한다.
- ③ chmod o+t /project: 이 명령어는 `/project` 디렉터리에 Sticky Bit를 설정한다. Sticky Bit는 디렉터리 내의 파일을 소유자나 루트 사용자만 삭제할 수 있도록 한다.
- ④ chmod g+t /project: Sticky Bit는 주로 `o+t`로 설정하며, 그룹에 대해서는 적용되지 않는다.

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/19.png)

- 리눅스에서, 파일(File)을 사용해 할 수 있는 작업은 크게 세 가지로 나눌 수 있다.
    - 파일에 저장된 데이터를 읽기(r = read)
    - 파일에 데이터를 쓰기(w = write)
    - 파일 실행(x = execute)
- chmod 다음에 "선택 옵션"과 "모드를 나타내는 문자열", 그리고 "대상 파일(또는 디렉토리)"을 순서대로 입력하여 파일의 모드를 변경할 수 있다.
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/20.png)
    
- "ls -l" 명령을 실행하면, 현재 디렉토리 내 파일 리스트(ls=list)가 하나의 파일 단위로 한줄로 길게(-l=long) 표시되는데, 공백 기준으로 가장 첫 번째 항목(-rw-r--r--)이 파일 소유자 별 권한, 세 번째(ppotta)와 네 번째(manager) 항목이 각각 파일 소유자와 그룹을 나타낸다.
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/21.png)
    
- 앞서 실행한 "ls -l" 명령의 실행 결과를 해석하면, 그 결과는 아래와 같다.
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/22.png)
    
- **chmod** 명령은 바로 이러한 파일의 권한을 변경할 수 있게 만들어주는 명령이다. "**ch**ange"와 "**mod**e"의 앞 글자들을 조합한 이름이다.(chmod = ch + mod)

---

Q. 다음 중 디렉터리에 부여되는 x(execute) 권한에 대한 설명으로 알맞은 것은?

> ②
> 

① ls 명령을 사용해서 디렉터리 안에 있는 파일 목록을 볼 수 있다.

② cd 명령을 사용해서 디렉터리 안으로 들어갈 수 있다.

③ 디렉터리 안에 있는 실행 파일을 실행할 수 있다.

④ 디렉터리 안에 실행 파일을 생성할 수 있다.

- **②** 디렉토리에 실행(x) 권한이 부여되면 사용자는 `cd` 명령어를 사용하여 해당 디렉토리로 이동할 수 있다. 실행 권한은 디렉토리에 접근할 수 있도록 허용하는 기본적인 권한이다.
- **① ls 명령을 사용해서 디렉터리 안에 있는 파일 목록을 볼 수 있다**: 읽기(r) 권한과 관련이 있다. 읽기 권한이 있어야 `ls` 명령어로 디렉토리 내의 파일 목록을 볼 수 있다.
- **③ 디렉터리 안에 있는 실행 파일을 실행할 수 있다**: 파일에 대한 실행(x) 권한과 관련된 설명이다. 디렉토리의 실행 권한은 파일 실행과 직접적인 관련이 없다.
- **④ 디렉토리 안에 실행 파일을 생성할 수 있다**: 쓰기(w) 권한과 관련이 있다. 쓰기 권한이 있어야 디렉토리에 파일을 생성하거나 삭제할 수 있다.

---

Q. XFS 파일 시스템 기반의 서버를 운영하고 있다. 다음 중 이 서버의 파일 시스템을 점검하는 방법으로 가장 알맞은 것은?

> ③
> 

① fsck 명령을 이용해서 점검한다.

② e2fsck 명령을 이용해서 점검한다.

③ xfs_repair 명령을 이용해서 점검한다.

④ btrfs-check 명령을 이용해서 점검한다.

- **xfs_repair**: XFS 파일 시스템의 손상이나 오류를 점검하고 복구하는 데 사용되는 명령어다. XFS 파일 시스템은 다른 파일 시스템과 달리 부팅 시 자동으로 fsck가 실행되지 않기 때문에, 문제가 발생했을 때 수동으로 `xfs_repair`를 실행해야 한다. 이 명령어는 파일 시스템이 마운트되지 않았거나 읽기 전용으로 마운트된 상태에서만 작동한다.
- **fsck**: 일반적인 파일 시스템 검사 도구이지만, XFS 파일 시스템에는 직접 사용할 수 없다. XFS는 자체적인 검사 및 복구 도구인 `xfs_repair`를 사용해야 한다.(file system check)
- **e2fsck**: ext2/ext3/ext4 파일 시스템을 위한 검사 및 복구 도구로, XFS와는 관련이 없다.
- **btrfs-check**: Btrfs 파일 시스템을 위한 검사 도구로, XFS와는 관련이 없다.

---

Q. 다음과 같이 허가권이 설정된 경우에 관련 설명으로 알맞은 것은?

> ④
> 

```bash
[root@www ~]# ls -l /usr/bin/passwd
-rwsr-xr-x. 1 root root 27856 Apr 1 2020 /usr/bin/passwd
```

① 이 파일은 root 사용자만이 실행할 수 있다.

② ihduser 사용자가 실행하면 ihduser 사용자 권한으로 실행된다.

③ ihduser 사용자가 실행하면 실행하는 동안 root 그룹 권한으로 인정된다.

④ ihduser 사용자가 실행하면 실행하는 동안 root 사용자 권한으로 인정된다.

- UserID에 StickyBit가 세팅되어 있다. 따라서, Set-UID 비트에 의해 `passwd` 명령어는 일반 사용자가 실행하더라도 root 권한으로 동작하게 된다.
- 파일 `/usr/bin/passwd`의 허가권 설정에 대한 설명으로 알맞은 것은 **④ ihduser 사용자가 실행하면 실행하는 동안 root 사용자 권한으로 인정된다**이다.
- **Set-UID 비트 (`s`)**: 파일의 소유자 권한으로 프로그램이 실행되도록 설정하는 특수 권한이다. `/usr/bin/passwd` 파일은 `rwsr-xr-x`로 설정되어 있으며, 이는 Set-UID 비트가 설정되어 있음을 나타낸다. 따라서, 이 파일을 실행하는 사용자는 파일 소유자의 권한, 즉 root 권한으로 프로그램을 실행하게 된다.

- **① 이 파일은 root 사용자만이 실행할 수 있다**: 파일의 실행 권한은 모든 사용자에게 (`r-x`) 부여되어 있다.
- **② ihduser 사용자가 실행하면 ihduser 사용자 권한으로 실행된다**: Set-UID 비트 때문에 root 권한으로 실행된다.
- **③ ihduser 사용자가 실행하면 실행하는 동안 root 그룹 권한으로 인정된다**: Set-GID 비트가 아닌 Set-UID 비트가 설정되어 있으므로 그룹 권한이 아닌 사용자 권한이 적용된다.

# [2과목] 리눅스 활용

---

Q. 다음 설명에 해당하는 용어로 알맞은 것은?

> ②
> 

```
2009년 2월 BMW, 델파이, GM, 윈드리버 등이 설립하여 만든 리눅스 운영체제 기반의 표준화된 자동차용 IVI 플랫폼이다.
```

① QNX

② GENIVI

③ webOS

④ Tizen

- **GENIVI**: GENIVI는 2009년 2월에 BMW, 델파이, GM, 윈드리버 등이 설립하여 만든 리눅스 운영체제 기반의 표준화된 자동차용 IVI(In-Vehicle Infotainment) 플랫폼이다. 이 플랫폼은 차량 인포테인먼트 시스템의 오픈 소스 개발과 규격화를 목표로 하는 비영리 협의체로, 자동차 산업에서 널리 사용되는 레퍼런스 플랫폼을 제공한다.
- **QNX**: 실시간 운영체제로, 주로 임베디드 시스템에서 사용되며, IVI 플랫폼으로도 사용되지만 GENIVI와는 다른 제품이다.(유닉스)
    - 유닉스 기반
- **webOS**: 원래 스마트폰용으로 개발된 운영체제로, LG에 의해 스마트 TV 등 다양한 기기에 사용되고 있다.(LG와 하고 있는 리눅스)
    - 리눅스 기반
        - LG 전자, 모바일 운영체제
- **Tizen**: 리눅스 재단이 주도하는 오픈 소스 운영체제로, 모바일 기기와 가전제품 등 다양한 분야에서 사용된다.(삼성과 하는 리눅스)
    - 리눅스 기반, 인텔과 삼성전자 공동 개발. 모바일 및 IT기기 지원

---

Q. 다음 중 CPU 전가상화 및 반가상화를 모두 지원하는 가상화 기술로 알맞은 것은?

> ①
> 

① Xen

② KVM

③ Docker

④ VirtualBox

- 반가상화까지 지원하는 것은 Xen
- **Xen**: Xen은 전가상화(Full Virtualization)와 반가상화(Paravirtualization)를 모두 지원하는 하이퍼바이저이다. Xen은 하드웨어 가상화 기술(Intel VT, AMD-V)을 활용하여 전가상화를 구현할 수 있으며, 또한 반가상화를 통해 성능을 최적화할 수 있는 기능도 제공한다.
- **KVM**: 주로 전가상화를 지원하는 하이퍼바이저로, 하드웨어 가상화 기술을 필요로 한다.
- **Docker**: 컨테이너 기반의 가상화 기술로, 전통적인 의미의 하드웨어 가상화와는 다르다.
    - 이미지 컨테이너, 쿠버네티스
- **VirtualBox**: 주로 전가상화를 지원하는 데스크톱 가상화 소프트웨어다.

---

Q. 다음 중 슈퍼컴퓨터와 같이 빠른 수치 연산이 필요한 경우에 구축하는 시스템으로 알맞은 것은?

> ③
> 

① LVS Cluster

② HA Cluster

③ HPC Cluster

④ Load Balance Cluster

- **HPC Cluster (High-Performance Computing Cluster)**: 고성능 컴퓨팅(HPC) 클러스터는 여러 대의 컴퓨터(노드)로 구성되어 복잡한 계산 작업을 고속으로 수행하는 시스템이다. 이러한 클러스터는 병렬 컴퓨팅을 활용하여 대규모 데이터를 처리하고 복잡한 문제를 해결하는 데 사용된다. HPC 클러스터는 슈퍼컴퓨터와 유사한 역할을 하며, 과학 연구, 엔지니어링, 시뮬레이션, 데이터 분석 등 다양한 분야에서 활용된다.
- **LVS Cluster**: 주로 네트워크 로드 밸런싱을 위한 클러스터로, 수치 연산보다는 네트워크 트래픽 관리에 중점을 둔다.
    - LVS는 **Linux Virtual Server**의 약자로, 고가용성과 고성능을 제공하기 위해 여러 대의 서버를 클러스터로 묶어 하나의 가상 서버처럼 동작하도록 하는 기술이다. LVS는 주로 로드 밸런싱을 통해 여러 서버에 걸쳐 트래픽을 분산시켜 서비스의 신뢰성과 성능을 향상시키는 데 사용된다. 이 시스템은 활성 LVS 라우터와 백업 LVS 라우터로 구성되어 있으며, 활성 라우터는 실제 서버들 간의 부하를 분산하고 각 서버의 서비스 상태를 점검하는 역할을 한다.
- **HA Cluster (High Availability Cluster)**: 시스템의 가용성을 높이기 위해 설계된 클러스터로, 장애 발생 시 서비스가 중단되지 않도록 하는 데 중점을 둔다.(고가용성)
- **Load Balance Cluster**: 여러 서버에 걸쳐 작업 부하를 분산시켜 효율성을 높이는 클러스터로, 주로 웹 서버와 같은 환경에서 사용된다.

---

Q. 다음 설명에 해당하는 프로그램으로 알맞은 것은?

> ③
> 

```
리눅스 재단의 하위 재단인 CNCF(Cloud Native Computing Foundation)에서 개발하는 오픈소스 프로젝트로
컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화해준다.
```

① Docker

② Openstack

③ Kubernetes

④ Ansible

- **Kubernetes**: Kubernetes는 리눅스 재단의 하위 재단인 CNCF(Cloud Native Computing Foundation)에서 개발하는 오픈소스 프로젝트로, **컨테이너화된 애플리케이션(Docker)**의 배포, 확장, 관리를 자동화하는 플랫폼이다. 이 기술은 컨테이너 오케스트레이션을 통해 대규모의 컨테이너를 효율적으로 관리할 수 있도록 설계되었으며, 자동화된 배포, 확장, 롤백 기능을 제공한다.
- **Docker**: Docker는 컨테이너를 생성하고 관리하는 데 사용되는 플랫폼으로, Kubernetes와 함께 사용되어 컨테이너의 배포 및 관리를 수행한다.
- **Openstack**: Openstack은 클라우드 인프라를 구축하고 관리하기 위한 오픈소스 소프트웨어로, 주로 IaaS(Infrastructure as a Service)를 제공하는 데 사용된다.
- **Ansible**: Ansible은 IT 자동화를 위한 도구로, 서버 설정 및 애플리케이션 배포를 자동화하는 데 사용된다.

---

Q. 다음 중 이더넷 카드에 연결된 케이블의 상태를 확인할 수 있는 명령어로 알맞은 것은?

> ④
> 

① route

② arp

③ ifconfig

④ ethtool

- **ethtool**: 이 명령어는 네트워크 인터페이스의 하드웨어 설정을 확인하고 변경하는 데 사용된다. 특히, 이더넷 카드에 연결된 케이블의 상태, 속도, 듀플렉스 모드 등을 확인할 수 있다. `ethtool`을 사용하면 네트워크 인터페이스의 물리적 연결 상태를 점검할 수 있어 케이블 문제를 진단하는 데 유용하다.
- **route**: 네트워크 라우팅 테이블을 보여주거나 수정하는 명령어로, 케이블 상태와는 관련이 없다.
- **arp**: ARP(Address Resolution Protocol) 캐시를 보여주거나 수정하는 명령어로, 네트워크 인터페이스의 물리적 상태를 확인할 수 없다.
- **ifconfig**: 네트워크 인터페이스의 설정을 보여주거나 변경하는 명령어로, 기본적으로 케이블의 물리적 상태를 직접 확인하지는 않는다.

---

Q. 다음 중 전자 메일과 가장 거리가 먼 프로토콜로 알맞은 것은?

> ②
> 

① POP3

② SNMP

③ SMTP

④ IMAP

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/23.png)

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/24.png)

- **SNMP(Simple Network Management Protocol)**: 네트워크 장치를 모니터링하고 관리하기 위한 인터넷 표준 프로토콜로, 라우터, 스위치, 서버 등의 네트워크 장치를 관리하는 데 사용된다. 전자 메일 송수신과는 직접적인 관련이 없다.
- 다른 프로토콜들의 전자 메일 관련 기능:
    - **IMAP**: 이메일을 서버에 저장하고 동기화하는 프로토콜(받았을 때, 포트번호 143)
    - **POP3**: 이메일을 서버에서 클라이언트로 다운로드하는 프로토콜(받았을 때 확인, 포트번호 110)
    - **SMTP**: 이메일을 송신하는 프로토콜(보낼 때, 포트번호 25)

---

Q. 다음 중 OSI 7계층 모델에서 물리 계층의 데이터 전송 단위로 알맞은 것은?

> ④
> 

① frame

② packet

③ socket

④ bit

- **bit**: 물리 계층(Physical Layer)은 데이터를 0과 1의 비트 형태로 전송한다. 이 계층은 전기적, 기계적, 물리적 특성에 집중하여, 네트워크 케이블과 같은 물리 매체를 통해 비트를 전송하는 역할을 한다.
- **frame**: 데이터 링크 계층(Data Link Layer)에서 사용되는 데이터 단위
- **packet**: 네트워크 계층(Network Layer)에서 사용되는 데이터 단위
- **socket**: 네트워크 연결을 위한 소프트웨어 인터페이스로, 특정 계층의 데이터 전송 단위가 아니다.

- 물데네전세표응
    - bit frame packet segmet
    - 물리계층은 리피터
    - 물리계층과 데이터링크 계층을 묶는 것은  브릿지
        - 데이터링크 계층엔 MAC 주소
    - 네트워크엔 라우터

---

Q. 다음에서 설명하는 네트워크 종류로 알맞은 것은?

> ②
> 

```
국가, 대륙 등과 같은 넓은 지역을 연결하는 네트워크이다.
거리상의 제약이 없지만 다양한 경로를 경유해서 도달하므로 속도가 느리고 전송 에러율도 높다.
```

① MAN 

② WAN

③ LAN

④ X.25

- **① MAN (Metropolitan Area Network)**: 도시 규모의 지역을 연결하는 네트워크로, 일반적으로 도시나 대도시권 내의 여러 LAN을 연결한다.
- **② WAN (Wide Area Network)**: 국가, 대륙 등과 같은 넓은 지역을 연결하는 네트워크이다. WAN은 다양한 경로를 경유하여 데이터를 전송하므로 속도가 느리고 전송 에러율이 높을 수 있다. WAN은 여러 LAN을 연결하여 광범위한 지역에 걸쳐 네트워크를 형성한다.
- **③ LAN (Local Area Network)**: 좁은 지역, 예를 들어 한 건물이나 캠퍼스 내에서 사용되는 네트워크다. 속도가 빠르고 에러율이 낮다.
- **④ X.25**: 오래된 패킷 교환 네트워크 프로토콜로, 주로 공공 데이터망에서 사용되었다. 현재는 거의 사용되지 않는다.

---

Q. 다음 설명에 해당하는 프로토콜로 알맞은 것은?

> ③
> 

```
세그먼트를 보내기만 하고 응답을 주고받지 않는 프로토콜이어서 
제대로 전달되었는지 확인하지 않으며 오류 수정도 하지 않는다.
```

① TCP

② IP

③ UDP

④ HTTP

- **① TCP (Transmission Control Protocol)**: 연결 지향형 프로토콜로, 데이터 전송 전에 연결을 설정하고, 데이터가 제대로 전달되었는지 확인하며 오류를 수정한다. 따라서 세그먼트의 전달 여부를 확인하고 오류 수정 기능이 있다.
- **② IP (Internet Protocol)**: 네트워크 계층에서 사용되는 프로토콜로, 데이터 패킷을 목적지까지 전달하는 역할을 한다. IP 자체는 데이터의 전송 여부를 확인하거나 오류 수정을 하지 않는다.
- **③ UDP (User Datagram Protocol)**: 비연결형 프로토콜로, 데이터를 보내기만 하고 수신 여부를 확인하지 않으며 오류 수정도 하지 않는다. UDP는 빠른 전송이 필요하지만 데이터의 신뢰성이 덜 중요한 경우에 사용된다.
- **④ HTTP (Hypertext Transfer Protocol)**: 웹에서 데이터를 주고받기 위해 사용되는 프로토콜로, 기본적으로 TCP 위에서 동작하여 데이터의 신뢰성을 보장한다.

---

Q. 다음 설명에 해당하는 도메인으로 알맞은 것은?

> ④
> 

```
비영리 목적의 기관이나 단체 등에서 사용할 수 있다.
```

① com

② mil

③ int

④ org

- **① com**: 주로 상업적 목적으로 사용되는 도메인이다. 기업이나 사업체가 주로 사용한다.(company, 삼성닷컴)
- **② mil**: 군사 기관에서 사용하는 도메인이다. 주로 미국 군대와 관련된 사이트에서 사용된다.(밀리터리)
- **③ int**: 국제 기구에서 사용하는 도메인이다. 예를 들어, 국제연합과 같은 국제적인 조직에서 사용된다.(인터내셔널)
- **④ org**: 비영리 목적의 기관이나 단체에서 주로 사용하는 도메인이다. 이 도메인은 비영리 단체, 자선 단체, 문화 및 종교 기관 등에서 신뢰성과 무결성을 나타내기 위해 사용된다. org 도메인은 비영리적 가치와 공익을 상징하며, 이러한 조직들이 온라인에서 권위 있는 이미지를 구축하는 데 도움을 준다.
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/25.png)
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/26.png)
    
    - 최상위 도메인: com, net, org, mil, kr

---

Q. 다음 설명에 해당하는 국제기구로 알맞은 것은?

> ②
> 

```
전기 및 전자공학 분야의 전문가로 구성된 국제조직으로
컴퓨터 네트워크 분야의 LAN 및 MAN 관련 표준을 제정하였다.
```

① ISO

② IEEE

③ ITU

④ ANSI

- **① ISO (International Organization for Standardization)**: 다양한 산업 분야에서 국제 표준을 개발하고 발행하는 기구이다.
- **② IEEE (Institute of Electrical and Electronics Engineers)**: 전기 및 전자공학 분야의 전문가로 구성된 국제조직으로, 특히 IEEE 802 LAN/MAN Standards Committee를 통해 LAN 및 MAN 관련 표준을 제정한다. 이 표준에는 Ethernet, Wireless LAN, Wireless MAN 등이 포함된다.
- **③ ITU (International Telecommunication Union)**: 국제 전기통신 연합으로, 주로 전 세계 통신 표준과 규제를 담당하지만, LAN 및 MAN의 세부적인 표준 제정은 IEEE가 주로 담당한다.
- **④ ANSI (American National Standards Institute)**: 미국의 국가 표준을 개발하고 조정하는 기구로, 국제적인 네트워크 표준 제정보다는 미국 내 표준화에 초점을 맞추고 있다.

---

Q. 다음 설명에 해당하는 프로토콜로 알맞은 것은?

> ④
> 

```
메시지에 대한 오류 보고와 이에 대한 피드백을 원래 호스트에 보고하는 역할을 수행한다.
ping 명령이 사용하는 프로토콜이다.
```

① IP 

② ARP

③ UDP

④ ICMP

- **① IP (Internet Protocol)**: 데이터 패킷을 네트워크를 통해 전송하는 역할을 하지만, 오류 보고 및 피드백 기능은 없다.
- **② ARP (Address Resolution Protocol)**: IP 주소를 물리적 하드웨어 주소로 변환하는 프로토콜로, 오류 보고와는 관련이 없다.
- **③ UDP (User Datagram Protocol)**: 비연결형 프로토콜로, 데이터의 신뢰성을 보장하지 않으며 오류 보고 기능이 없다.
- **④ ICMP (Internet Control Message Protocol)**: 네트워크 계층에서 오류 메시지와 운영 정보를 전송하는 데 사용되는 프로토콜이다. ICMP는 네트워크 문제를 진단하고 오류를 보고하는 데 사용되며, `ping` 명령어가 이 프로토콜을 사용하여 네트워크 연결 상태를 확인한다.
    - 네이버는 핑에 답변해주지 않고, 구글은 답변해준다.

---

Q. 다음 중 로컬 루프백(Local Loopback) 장치에 할당되는 IP 주소로 알맞은 것은?

> ③
> 

① 10.0.0.1

② 125.255.255.0

③ 127.0.0.1

④ 192.168.0.1

- **① 10.0.0.1**: 이 주소는 일반적으로 사설 네트워크에서 사용되는 IP 주소이다.
- **② 125.255.255.0**: 이 주소는 공인 IP 주소 범위에 속한다.
- **③ 127.0.0.1**: 이 주소는 IPv4에서 루프백 주소로 사용된다. 루프백 주소는 컴퓨터가 자체적으로 네트워크 연결을 테스트하거나 네트워크 소프트웨어를 개발할 때 사용된다.
- **④ 192.168.0.1**: 이 주소는 일반적으로 사설 네트워크에서 게이트웨이로 사용되는 IP 주소이다.

---

Q. 다음 중 웹키트 레이아웃 엔진을 이용해서 개발한 프리웨어 웹 브라우저로 알맞은 것은?

> ①
> 

① 크롬 

② 파이어폭스

③ 사파리

④ 인터넷 익스플로어

- 웹키트 레이아웃 엔진을 이용하여 구글이 개발중인 프리웨어 웹 브라우저이다.
- **① 크롬 (Chrome)**: 초기에는 웹키트 엔진을 사용했지만, 현재는 블링크(Blink) 엔진을 사용하고 있다.
- **② 파이어폭스 (Firefox)**: 게코(Gecko) 엔진을 사용하는 웹 브라우저다.
- **③ 사파리 (Safari)**: 애플이 개발한 웹 브라우저로, 웹키트(WebKit) 엔진을 사용한다.
- **④ 인터넷 익스플로어 (Internet Explorer)**: 트라이던트(Trident) 엔진을 사용하는 브라우저다.

---

Q. 다음 설명에 해당하는 인터넷 서비스로 알맞은 것은?

> ④
> 

```
회사 내 리눅스 서버를 운영 중이고, 회사 내 개발자들 모두 리눅스를 사용 중이다.
특정 리눅스 시스템에 공유 디렉터리를 생성하고 부팅과 동시에 손쉽게 접근할 수 있는 환경을 제공하려고 한다.
```

① Usenet

② ssh

③ POP3

④ NFS

- **① Usenet**: 뉴스 그룹을 통해 메시지를 전송하고 읽을 수 있는 시스템이다.(토론)
- **② ssh (Secure Shell)**: 네트워크 상에서 다른 컴퓨터에 안전하게 접속하기 위한 프로토콜로,원격 접속 및 명령 실행에 사용된다.(Secure하게 연결)
- **③ POP3 (Post Office Protocol 3)**: 이메일을 클라이언트가 서버로부터 가져오는 데 사용하는 프로토콜이다.(전자메일 프로토콜)
- **④ NFS (Network File System)**: 네트워크를 통해 파일 시스템을 공유할 수 있도록 해주는 프로토콜이다. NFS는 리눅스 및 유닉스 시스템에서 주로 사용되며, 클라이언트가 서버의 파일 시스템을 로컬 파일 시스템처럼 마운트하여 사용할 수 있다. 이를 통해 부팅 시 자동으로 마운트 설정을 할 수 있어, 사용자가 별도의 조작 없이도 쉽게 접근할 수 있는 환경을 제공한다,(네트워크 상에서 파일을 잘 활용하는 시스템,,, 디렉토리 생성,,)

---

Q. 다음 설명에 해당하는 netstat 명령의 상태값(State)으로 알맞은 것은?

> ②
> 

```
서버에서 클라이언트로부터 들어오는 패킷을 위해 소켓을 열고 기다리는 상태이다.
```

① SYN_RECEIVED

② LISTEN

③ ESTABLISHED

④ SYN-SENT

- **SYN-SENT**:  **SYN_SENT**는 클라이언트가 서버에 연결 요청(SYN 패킷)을 보내고, 서버의 응답(SYN-ACK 패킷)을 기다리고 있는 상태이다.
- **LISTEN**: 이 상태는 서버가 클라이언트로부터 들어오는 연결 요청을 기다리기 위해 소켓을 열고 대기하는 상태이다. 서버의 포트가 열려 있고, 클라이언트의 연결 요청을 수신할 준비가 되어 있다.
- **SYN_RECEIVED**: 이 상태는 서버가 클라이언트로부터 SYN 패킷(연결 요청)을 수신하고, 이에 대한 응답으로 SYN-ACK 패킷을 보낸 후, 클라이언트의 ACK 패킷을 기다리는 중간 상태이다.  이는 TCP 3-way 핸드셰이크 과정의 일부이다.
- **ESTABLISHED**: 이 상태는 TCP 연결이 성공적으로 설정된 상태를 의미한다. 양쪽 끝에서 데이터를 주고받을 수 있는 상태로, 클라이언트와 서버 간의 통신이 활성화되어 있다.

---

Q. 다음 중 일반적인 FTP data 포트 번호로 알맞은 것은?

> ①
> 

① 20

② 21

③ 22

④ 25

- 일반적인 FTP 데이터 포트 번호는 **20**, 제어는 **21**
- **① 20**: FTP의 데이터 전송에 사용되는 포트이다. FTP는 두 개의 포트를 사용하여 작동하며, 포트 20은 데이터 전송에 사용된다.
- **② 21**: FTP의 제어 명령을 처리하는 데 사용되는 포트이다. 클라이언트가 서버에 연결 요청을 하고 명령을 전송하는 데 사용된다.
- **③ 22**: SSH 및 SFTP(Secure File Transfer Protocol)에 사용되는 포트이다. FTP와는 관련이 없다.
    - 23번은 Telnet
- **④ 25**: SMTP(Simple Mail Transfer Protocol)에 사용되는 포트로, **이메일 전송**에 사용된다. FTP와는 관련이 없다.

---

Q. 다음 중 IPv6의 주소 범위로 알맞은 것은?

> ③
> 

① 32bit

② 64bit

③ 128bit

④ 1024bit

- 8888은 IPv4, 다 합쳐진 32씩 하는 것은 IPv6
- **① 32bit**: IPv4의 주소 범위
- **③ 128bit**: IPv6 주소는 총 128비트로 구성되어 있으며, 이는 IPv4의 32비트에 비해 훨씬 큰 주소 공간을 제공한다.
- **④ 1024bit**: 현재 사용되는 IP 주소 체계 중에는 해당되지 않는다.

---

Q. 다음 중 장애 발생 시에도 다른 시스템에 영향이 적고, 우회할 수 있는 방법이 존재하여 신뢰성이 높은 LAN 구성 방식으로 알맞은 것은?

> ①
> 

① 망형

② 링형

③ 스타형

④ 버스형

- 링형 : 하나가 끊어지면 전체 시스템이 망가진다.
- 스타형 : * 일부에 장애가 생겨도 전체에는 이상이 없다.
- 버스형 : 양 종단이 존재, 한 번에 한 번씩 작동
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/27.png)
    
    ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/28.png)
    

- **① 망형(Mesh)**: 모든 노드가 서로 연결된 형태로, 한 경로에 장애가 발생하더라도 다른 경로를 통해 데이터 전송이 가능하여 신뢰성이 높다. 장애 발생 시 우회 경로를 사용할 수 있어 다른 시스템에 영향을 적게 미친다.
- **② 링형(Ring)**: 노드가 원형으로 연결된 형태로, 단방향일 경우 하나의 노드가 고장나면 전체 네트워크에 영향을 미칠 수 있다. 양방향일 경우에는 우회가 가능하지만, 구조 변경이 어렵다.
- **③ 스타형(Star)**: 중앙 노드(허브 또는 스위치)를 통해 모든 노드가 연결된 형태이다. 중앙 노드가 고장나면 전체 네트워크에 영향을 미치지만, 개별 노드의 장애는 다른 노드에 영향을 주지 않는다.
- **④ 버스형(Bus)**: 모든 노드가 하나의 통신 회선을 공유하는 형태로, 회선 자체에 문제가 생기면 전체 네트워크에 영향을 미칠 수 있다. 구조는 간단하지만 확장성이나 신뢰성 면에서 한계가 있다.

---

Q. 다음 설명에 해당하는 OSI 계층으로 알맞은 것은?

> ②
> 

```
응용 프로그램 간의 통신을 관리하기 위한 방법과 동기화를 유지하는 서비스를 제공한다.
```

① 전송 계층

② 세션 계층

③ 표현 계층

④ 응용 계층

- **세션 계층 (Session Layer)**: 세션 계층은 두 응용 프로그램 간의 통신을 설정, 관리, 종료하는 역할을 담당한다. 이 계층은 데이터 교환을 위한 다이얼로그를 동기화하고, 세션 규칙을 처리하며, 효율적인 데이터 전송과 예외 처리를 수행한다.
- **전송 계층 (Transport Layer)**: 이 계층은 데이터 전송의 신뢰성을 보장하고, 오류 검출 및 복구, 흐름 제어 등을 담당한다. 대표적인 프로토콜로는 TCP와 UDP가 있다.
- **표현 계층 (Presentation Layer)**: 이 계층은 데이터의 형식 변환, 압축, 암호화 등을 담당하여 송신자와 수신자 간의 데이터 표현을 일관되게 유지한다.
- **응용 계층 (Application Layer)**: 사용자와 가장 가까운 계층으로, 이메일 전송, 파일 전송, 웹 브라우징 등과 같은 응용 프로그램 서비스를 제공한다.
- 이들 각 계층은 네트워크 통신에서 특정한 역할을 수행하여 전체 시스템의 효율성과 신뢰성을 보장한다.

---

Q. 다음 설명에 가장 적합한 서비스로 알맞은 것은?

> ④
> 

```
인터넷 기반의 문서 검색 시스템으로 **텍스트** 기반의 메뉴 인터페이스를 통해 정보 검색 기능을 제공한다.
터미널 환경을 기반으로 **대량의 정보 검색** 및 저장을 위해 사용되었다.
```

① WWW 

② SAMBA

③ TELNET

④ GOPHER

- 텔넷은 평문 전송 → SSH
- SAMBA: 윈도우와 프린터, 파일 공유
- **Gopher**: Gopher는 인터넷 기반의 문서 검색 시스템으로, 텍스트 기반의 메뉴 인터페이스를 통해 정보 검색 기능을 제공한다. 터미널 환경을 기반으로 대량의 정보 검색 및 저장을 위해 사용되었다. Gopher는 계층적 메뉴 시스템을 사용하여 사용자가 원격 서버에서 파일을 탐색하고 액세스할 수 있도록 한다.
- **WWW (World Wide Web)**: WWW는 하이퍼텍스트를 통해 인터넷 상의 정보를 브라우징할 수 있는 시스템이다. 주로 그래픽 사용자 인터페이스(GUI)를 사용하며, HTTP 프로토콜을 통해 작동한다. Gopher와 달리 웹 페이지를 통해 이미지와 멀티미디어 콘텐츠를 쉽게 접근할 수 있다.
- **SAMBA**: SAMBA는 네트워크 파일 공유 서비스로, 주로 Windows와 Unix/Linux 시스템 간의 파일 및 프린터 공유를 지원한다. 인터넷 기반 문서 검색 시스템과는 관련이 없다.
- **TELNET**: Telnet은 원격 컴퓨터에 접속하여 명령어를 실행할 수 있는 원격 접속 서비스이다. 주로 텍스트 기반의 터미널 에뮬레이션 프로토콜로 사용되며, 보안성이 낮아 SSH로 대체되고 있다.

---

Q. 다음 설명과 관련 있는 파일로 알맞은 것은?

> ①
> 

```
IP 주소를 이용해서 자주 방문하던 사이트를 나만의 **별명**을 부여하여 손쉽게 접속하려고 한다.
```

① /etc/**hosts**

② /etc/resolv.conf

③ /etc/sysconfig/network

④ /etc/sysconfig/network-scripts

- **/etc/hosts**: 이 파일은 IP 주소와 호스트 이름을 매핑하여, 사용자가 자주 방문하는 사이트에 별명을 부여하고 쉽게 접속할 수 있도록 한다. DNS 서버를 거치지 않고도 직접 IP 주소를 지정할 수 있어, 개인적으로 자주 방문하는 사이트에 대해 별칭을 설정하는 데 유용하다.
    - IP와 도메인명이 매핑된 파일
- **/etc/resolv.conf**: 이 파일은 DNS 서버의 주소를 지정하여, 시스템이 도메인 이름을 IP 주소로 변환할 때 사용할 네임 서버를 설정한다. 주로 네트워크 설정에서 자동으로 생성되며, 수동으로 편집할 수도 있다.
    - 네임 서버가 기록되어 있는 파일
- **/etc/sysconfig/network**: 이 파일은 시스템의 **네트워크 설정과 관련**된 기본 정보를 담고 있으며, 네트워크 장치의 이름이나 기본 게이트웨이 등을 설정한다.
    - 외부 네트워크와의 연결 차단 시 설정
- **/etc/sysconfig/network-scripts**: 이 디렉토리는 각 **네트워크 인터페이스**의 개별 설정 파일을 포함하고 있으며, 네트워크 인터페이스의 IP 주소, 서브넷 마스크, 게이트웨이 등을 설정하는 데 사용된다.
    - 네트워크 인터페이스 환경설정과 관련된 파일
- /etc/services: 모든 프로토콜이 기록된 파일
- /etc/protocols: 사용 가능한 프로토콜이 기록된 파일

---

Q. 다음 중 IPv4의 C클래스 대역에 할당된 사설 IP 주소의 네트워크 개수로 알맞은 것은?

> ④
> 

① 1

② 16

③ 192

④ 256

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/29.png)

- IPv4의 C클래스 대역에 할당된 사설 IP 주소의 네트워크 개수는 0~255로 총 256개
    - 네트워크와 로컬로 나누고, A클래스는 네트워크 1개 차지, B는 2개 차지, C는 3개 차지 → 마지막은 로컬이 하나(0~255)
- **C 클래스**: C 클래스의 IP 주소 범위는 192.0.0.0부터 223.255.255.255까지이다. 이 범위 내에서 사설 IP 주소로 사용되는 대역은 192.168.0.0부터 192.168.255.255까지다. 이 대역은 256개의 네트워크를 포함한다.

---

Q. 다음에서 설명하는 명령어로 알맞은 것은?

> ④
> 

```
www.ihd.or.kr 웹 서버가 https 프로토콜이 활성화되어 있는지 점검하려 한다. 
```

① telnet www.ihd.or.kr@80

② telnet www.ihd.or.kr 80

③ telnet www.ihd.or.kr@443

④ telnet www.ihd.or.kr 443

- HTTPS의 포트번호는 443, Telnet의 포트번호는 23
- telnet www.ihd.or.kr 443: 이 명령어는 Telnet을 사용하여 www.ihd.or.kr 웹 서버의 HTTPS 프로토콜(포트 443)이 활성화되어 있는지를 점검하기 위한 것이다. Telnet은 주로 HTTP(포트 80)와 같은 비보안 프로토콜을 테스트하는 데 사용되지만, HTTPS(포트 443)의 경우에는 보안 연결을 지원하지 않기 때문에 실제로는 OpenSSL과 같은 도구를 사용하는 것이 더 적합하다.

---

Q. 다음 설명에 해당하는 프로그램으로 알맞은 것은?

> ②
> 

```
GNU 프로젝트의 일환으로 만들어진 사진이나 그림을 편집하는 자유 소프트웨어이다.
그래픽이나 로고 디자인, 레이어 기법을 통한 움직이는 이미지 작업 등이 가능하다.
```

① Eog

② Gimp

③ Gwenview

④ Totem

- **GIMP (GNU Image Manipulation Program)**: GIMP는 GNU 프로젝트의 일환으로 개발된 무료 오픈 소스 이미지 편집 소프트웨어이다. 이 프로그램은 사진이나 그림을 편집할 수 있으며, 그래픽 디자인, 로고 디자인, 레이어 기법을 통한 이미지 합성 및 **움직이는 이미지 작업** 등을 지원한다. GIMP는 Photoshop과 유사한 기능을 제공하며, 다양한 운영 체제에서 사용할 수 있다.
- **Eog (Eye of GNOME)**: Eog는 GNOME 데스크톱 환경에서 기본적으로 제공되는 이미지 뷰어로, 주로 이미지 파일을 열고 보는 데 사용된다. 편집 기능은 제한적이다.
- **Gwenview**: Gwenview는 KDE 데스크톱 환경에서 제공되는 이미지 뷰어로, 빠르고 간단하게 이미지를 열고 볼 수 있다. 기본적인 편집 기능을 제공하지만, 전문적인 이미지 편집 소프트웨어는 아니다.
    - KDE에서 제공하는 이미지 뷰어 프로그램
- **Totem**: Totem은 GNOME 데스크톱 환경에서 사용되는 기본 미디어 플레이어로, 비디오 파일을 재생하는 데 사용된다.

---

Q. 다음 중 프레젠테이션(Presentation) 작업을 할 때 사용하는 프로그램으로 알맞은 것은?

> ③
> 

① LibreOffice Calc

② LibreOffice Writer

③ LibreOffice Impress

④ LibreOffice Draw

- **LibreOffice Impress**: Impress는 프레젠테이션을 만들고 수정하는 데 사용되는 프로그램으로, 다양한 슬라이드 템플릿과 애니메이션 효과를 지원한다. 사용자는 텍스트, 이미지, 비디오 및 기타 멀티미디어 요소를 포함하여 전문적인 프레젠테이션을 제작할 수 있다.
    - 프레젠테이션(PPT)
- **LibreOffice Calc**: Calc는 스프레드시트 프로그램으로, 데이터 분석 및 계산에 적합하다. 주로 표와 차트를 다루며, 프레젠테이션 작업과는 관련이 없다.
    - 스프레드시트(엑셀)
- **LibreOffice Writer**: Writer는 워드 프로세서로, 문서 작성 및 편집에 사용된다. 보고서, 편지, 논문 등을 작성하는 데 유용하지만, 프레젠테이션 작업에는 적합하지 않다.
    - 워드프로세서
- **LibreOffice Draw**: Draw는 벡터 그래픽 편집기이다. 다이어그램이나 그림을 만드는 데 유용하지만, 프레젠테이션 제작에 특화된 기능은 없다.
    - 드로잉

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ①
> 

```
GNU 프로젝트에 의해 만들어진 공개형 데스크톱 환경으로 GTK+ 라이브러리를 사용해서 개발되었다.
```

① GNOME

② Wayland

③ Mutter

④ metacity

- **GNOME**: GNOME은 GNU 프로젝트의 일환으로 개발된 공개형 데스크톱 환경이다. GTK+ 라이브러리를 사용하여 개발되었으며, 사용자 친화적인 경험을 제공하는 것을 목표로 설계되었다. GNOME은 다양한 리눅스 배포판에서 기본 데스크톱 환경으로 사용되며, 직관적이고 간결한 사용자 인터페이스를 제공한다.
- **Wayland**: Wayland는 디스플레이 서버 프로토콜로, X11을 대체하기 위해 개발되었다. 그래픽 성능을 향상시키고 보안을 강화하는 것을 목표로 한다.
- **Mutter**: Mutter는 GNOME의 기본 **윈도우 매니저**로, 컴포지팅 기능을 제공하여 창의 위치와 크기를 관리한다.(그놈3)
- **Metacity**: Metacity는 이전에 GNOME에서 사용되었던 **윈도우 매니저**로, 현재는 Mutter로 대체되었다. Metacity는 간단하고 가벼운 디자인을 특징으로 한다.(그놈2)
- KDE는 QT라이브러리와 연결된다.
    - **Gwenview**: Gwenview는 KDE 데스크톱 환경에서 제공되는 이미지 뷰어로, 빠르고 간단하게 이미지를 열고 볼 수 있다. 기본적인 편집 기능을 제공하지만, 전문적인 이미지 편집 소프트웨어는 아니다.
        - KDE에서 제공하는 이미지 뷰어 프로그램

---

Q. 다음 중 관련 명령어의 사용법으로 알맞은 것은?

> ④
> 

① xauth 192.168.5.13

② xhost 192.168.5.13

③ xauth add 192.168.5.13

④ xhost add 192.168.5.13

- **xhost**: 이 명령어는 **X 서버에 접속할 수 있는 클라이언트를 지정**하거나 해제하는 데 사용된다. `xhost` 명령어는 호스트 단위로 접근을 제어하며, 특정 IP 주소나 도메인명을 통해 접근을 허용하거나 금지할 수 있다.
    - X 서버에서 접근 가능한 IP 주소 및 호스트명 확인
        - + : IP나 도메인명을 이용해 접근 허가
        
        ```bash
        # (괄호) 192.168.5.13
        ```
        
        ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/30.png)
        
        ![img](/assets/img/exam/linux_level2/practice_tests/2023.03/31.png)
        
- **xauth 192.168.5.13** 및 **xauth add 192.168.5.13**: `xauth`는 X 서버의 인증 정보를 관리하는 도구로, 주로 .Xauthority 파일의 쿠키 내용을 추가, 삭제, 리스트를 출력하는 데 사용된다. IP 주소만으로는 올바른 사용법이 아니다.
    - X 서버에서 X 클라이언트 허가를 위해 **생성한 키 값**을 확인
        - xauth는 key 베이스로 나온다.
        
        ```bash
        # (괄호) list $DISPLAY
        ```
        

---

Q. 다음 중 원격지 X 서버에 응용 프로그램을 전송하기 위해 X 클라이언트에서 진행해야 하는 과정으로 알맞은 것은?

> ③
> 

① xauth 명령으로 서버 주소를 등록한다.

② xhost 명령으로 서버 주소를 등록한다.

③ 환경변수인 DISPLAY의 값을 서버 주소로 변경한다.

④ 환경변수인 TERM의 값을 서버 주소로 변경한다.

- **DISPLAY 환경변수 설정**: X 클라이언트가 원격지 X 서버에 응용 프로그램을 전송하기 위해서는 DISPLAY 환경변수를 설정해야 한다. 이 변수는 X 서버가 실행 중인 호스트와 디스플레이 번호를 지정하여, 클라이언트가 해당 서버로 그래픽 출력을 전송할 수 있도록 한다.
    - DISPLAY 환경변수: X 클라이언트 프로그램을 원격지의 X 서버로 전송
- **xauth 명령으로 서버 주소를 등록한다**: `xauth`는 X 서버의 인증 정보를 관리하는 도구로, DISPLAY 설정과는 직접적인 관련이 없다.
- **xhost 명령으로 서버 주소를 등록한다**: `xhost`는 특정 호스트의 X 서버 접근을 허용하거나 차단하는 명령어로, DISPLAY 환경변수 설정과는 다르다.
- **환경변수인 TERM의 값을 서버 주소로 변경한다**: `TERM` 환경변수는 터미널 타입을 지정하는 데 사용되며, X 서버와 관련이 없다.

---

Q. 다음 설명에 해당하는 명칭으로 알맞은 것은?

> ②
> 

```pascal
X 윈도 환경에서 윈도(window)의 배치와 표현을 담당하는 시스템 소프트웨어이다.
기능으로는 창 열기, 창 닫기, 최소화 및 최대화, 이동, 크기 조정 등이 있다.
```

① 데스크톱 환경 

② 윈도우 매니저

③ 디스플레이 매니저

④ 위젯

- **윈도우 매니저**: 윈도우 매니저는 X 윈도 환경에서 창의 배치와 표현을 담당하는 시스템 소프트웨어이다. 주요 기능으로는 창 열기, 닫기, 최소화 및 최대화, 이동, 크기 조정 등이 있다. 윈도우 매니저는 사용자가 그래픽 환경에서 창을 관리하고 조작할 수 있도록 도와주는 역할을 한다.
    - 윈도의 배치와 표현 담당(유틸리티 제공)
    - 창 열기와 닫기, 창 최소화 및 최대화, 창 이동, 창 크기 조정
    - Mutter, **Kwin**, Windowmaker
- **데스크톱 환경**: 데스크톱 환경은 사용자에게 그래픽 사용자 인터페이스(GUI)를 제공하는 소프트웨어 모음으로, 파일 관리자, 아이콘, 창, 도구 모음 등을 포함한다. GNOME, KDE 등이 대표적인 예이다.
    - GUI 환경을 이용하기 위해 사용자에게 제공되는 인터페이스 스타일
    - 파일 관리자, 아이콘, 창, 도구 모음, 폴더, 배경화면, 데스크톱 위젯 제공
    - KDE, GNOME, LXDE, **XFCE**
        - 관련 라이브러리
            - KDE: QT 라이브러리 기반
            - GNOME: GTK+ 라이브러리 기반
- **디스플레이 매니저**: 디스플레이 매니저는 사용자 로그인 및 세션 관리를 담당하는 프로그램이다. XDM, GDM, KDM 등이 있으며, 부팅 시 그래픽 로그인 화면을 제공하여 사용자의 인증을 처리한다.
    - 사용자 로그인 및 세션 관리
    - XDM, GDM, KDM
- **위젯**: 위젯은 사용자 인터페이스의 구성 요소로, 버튼, 스크롤바, 텍스트 입력 상자 등과 같이 사용자와 상호작용할 수 있는 개별적인 요소를 의미한다. 위젯은 윈도우 매니저의 기능과는 다르다.
- X윈도
    - 구성요소
        - Xlib: C언어로 구현된 클라이언트 라이브러리로 X 서버와 대화 가능
        - XCB: Xlib을 대체하기 위해 등장한 클라이언트 라이브러리
    - 특징
        - 네트워크 기반 그래픽 환경 지원
        - 이기종 시스템 사이에서도 사용 가능
        - X 컨소시엄에 의해 X11 버전이 처음으로 개정되어 X11R2가 발표

---

Q. 다음 중 리눅스에서 사용되는 데스크톱 환경으로 틀린 것은?

> ③
> 

① MATE

② LXDE

③ Xfwm

④ Xfce

- **MATE**: MATE는 GNOME 2를 기반으로 한 데스크톱 환경으로, 사용자에게 전통적인 데스크톱 경험을 제공한다.
- **LXDE**: LXDE는 **경량화된 데스크톱 환경**으로, 저사양 컴퓨터에서도 원활하게 작동하도록 설계되었다.
- **Xfce**: Xfce는 경량화와 속도에 중점을 둔 효율적인 데스크톱 환경으로, 저사양 장치에 적합하다.
- **Xfwm**: Xfwm은 Xfce 데스크톱 환경의 윈도우 매니저로, 창 관리 기능을 담당한다. Xfwm 자체는 데스크톱 환경이 아니며, Xfce의 일부 구성 요소이다. 따라서 데스크톱 환경으로 분류되지 않는다.

---

Q. 다음 (괄호) 안에 들어갈 내용으로 알맞은 것은?

> ④
> 

```pascal
CentOS 7 버전부터 systemd 기반으로 변화하면서 부팅 모드에 대한 표현도 변화되었다.
이전 버전인 init 체제에서는 X 윈도로 부팅되는 모드를 ( ㉠ )이라고 표기하였는데, 현재는 ( ㉡ )이라고 표기한다.
```

① ㉠ runlevel 3 ㉡ multi-user.target

② ㉠ runlevel 3 ㉡ graphical.target

③ ㉠ runlevel 5 ㉡ multi-user.target

④ ㉠ runlevel 5 ㉡ graphical.target

![img](/assets/img/exam/linux_level2/practice_tests/2023.03/32.png)

- 런레벨 5는 X 윈도우를 포함한 그래픽 환경을 제공하는 모드이며, 이는 systemd에서 graphical.target과 대응된다.
- 부팅 모드 설정
    - CLI로 부팅
        - systemctl set-default runlevel3
        - systemctl set-default multi-user.target
    - GUI로 부팅
        - systemctl set-default runlevel5
        - systemctl set-default graphical.target
    - etc/inittab
        - 부팅 모드를 설정할 수 있는 파일
        

<br>
**참고 자료**

---

- [https://www.liquidweb.com/blog/what-is-umask-and-how-to-use-it-effectively/?utm_source=perplexity : ls -l](https://www.liquidweb.com/blog/what-is-umask-and-how-to-use-it-effectively/?utm_source=perplexity)
- [https://youtu.be/cbNoaC6CSO0 : umask](https://youtu.be/cbNoaC6CSO0)
- [https://recipes4dev.tistory.com/175 : -  - 리눅스 chmod 명령어 사용법](https://recipes4dev.tistory.com/175)
- [https://cwpack0730.tistory.com/82 : 전가상화와 반가상화](https://cwpack0730.tistory.com/82)
- <https://www.contradodigital.com/2022/09/10/how-to-mount-a-disk-in-linux/two-disks-fdisk-command-linux/?utm_source=perplexity>
- <https://www.taek.co.kr/entry/Linux-fstab?utm_source=perplexity>
- <https://salesblink.io/blog/difference-between-smtp-imap-pop3>
- <https://www.gklibrarykor.com/525/?utm_source=perplexity>
- <https://biz.chosun.com/site/data/html_dir/2020/05/04/2020050402744.html?utm_source=perplexity>
- [https://hstory0208.tistory.com/entry/도메인과-DNS-란?utm_source=perplexity](https://hstory0208.tistory.com/entry/%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B3%BC-DNS-%EB%9E%80?utm_source=perplexity)
- [https://velog.io/@bsj1209/근거리-통신망-LAN-토폴로지와-LAN-프로토콜-구조?utm_source=perplexity](https://velog.io/@bsj1209/%EA%B7%BC%EA%B1%B0%EB%A6%AC-%ED%86%B5%EC%8B%A0%EB%A7%9D-LAN-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80%EC%99%80-LAN-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EA%B5%AC%EC%A1%B0?utm_source=perplexity)
- [https://velog.io/@mardi2020/네트워크-구조?utm_source=perplexity](https://velog.io/@mardi2020/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0?utm_source=perplexity)
- [https://www.machuda.kr/learning/certification/리눅스마스터2급/written/problem/82062](https://www.machuda.kr/learning/certification/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A7%88%EC%8A%A4%ED%84%B02%EA%B8%89/written/problem/82062)
- <https://www.youtube.com/watch?v=JuXu-T69V7I&t=254s>